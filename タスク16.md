# 📌 タイトル
- ［改訂新版］プロになるためのWeb技術入門

---

## 💼 業務で活かす場面
- フロントエンドアプリケーションの構築

---

## 🎯 学習目的
- WEBアプリケーションの基礎部分を理解する
- 各技術が生まれた背景や、実現可能なことを理解することによって、何故この技術が使われているのか、使うのかを理解しながら実装を行うことができる
- 実際のWEBアプリケーションのコードを読むことにより、コーディングのイメージを掴む

---

## 📝 全体の感想
- HTMLやJavaScript、Goを理解している前提で書かれているので、Goをまだそこまで理解できていない自分にとっては、一部のライブラリやメソッドの使い方などがわからず、コードを理解することに時間がかかる場合があった。
- 技術が生まれた背景についての説明もあるため、何故その技術が存在するのか、使う必要があるのかを理解しながら実装を行うことができた。

---

## 📖 内容の要約

### 全体構成
- 1.技術の学び方
- 2.WEBシステムの全体像
- 3.WWWの基本要素
- 4.HTTPクライアントとサーバ
- 5.URLとHTTPリクエスト
- 6.基礎的なWEBアプリケーション
- 7.SPA
- 8.WEB API
- 9.サーバープッシュ技術

#### 1.技術の学び方
- IT技術が世の中に浸透し、技術の種類もますます多様化していく中で、それらを理解しながらシステムを作り上げることが難しくなってきたと同時に、エンジニアに求められる技術レベルも高まりつつある
- 様々な技術が存在する中で、何か1つの技術のみを学ぶのではなく、まずはシステムの全体像を理解し、今学ぼうとしている技術がどのような位置付けにあるのか、その技術は他の技術とどのようなつながりがあるのかを理解しながら学んでいくことが重要になる

#### 2.WEBシステムの全体像
- クライアントサイドではデバイスの上にWEBブラウザが存在し、WEBブラウザの中にHTTPクライアントとレンダリングエンジン、JavaScriptエンジンなどが含まれる
- クライアントサイドからサーバーサイドにリクエストが送られると、サーバーサイドのWEBアプリケーションが、必要に応じてデータベースと連携しながらそれに応じたレスポンスを返す

#### 3.WWWの基本要素
- 現代のシステムは、WWWという仕組みを用いてデータのやり取りが行われている
- WWWの仕組みでは、それぞれの情報ソースにURIという一意のアドレスが付与され、HTTPを通じてそれぞれの情報ソースにアクセスすることができる
- やり取りするデータの形式には、HTML(CSS)やXMLが使われる

#### 4.HTTPクライアントとサーバ
- ncコマンドとcurlコマンドを用いて、HTTPサーバとHTTPクライアントを立ち上げ、擬似的なHTTP通信を実現することができる

#### 5.URLとHTTPリクエスト
- URLはコンピュータのリソースを一意に特定する手法であり、主に、スキーム、ホスト、ポート、パス、クエリ、フラグメントで構成される
- HTTPリクエストは、リクエストラインとヘッダー、ボディで構成され、リクエストラインは、メソッド、ターゲット、バージョンで構成される
- HTTPレスポンスもほぼ同様だが、リクエストラインは、バージョン、ステータスコード、リーズンで構成される

#### 6.基礎的なWEBアプリケーション
- Go言語を用いて、Todoリストの追加とリダイレクトを可能にする簡単なWEBアプリケーションを作成する
- WEBサーバは、クッキーを用いてユーザーのセッション情報を識別する
- セッション情報を元に認証を行うTodoアプリをGo言語で作成する
- WEBアプリケーションフレームワークは、認証、セッション管理、テンプレート、画面遷移、データベースアクセス支援などを効率的に実装できるメリットがある

#### 7.SPA
- Ajaxは、イベントドリブンプログラミングの仕組みを取り入れることによって、従来のアプリケーションの課題であった画面遷移やサーバー通知の課題を解消した。
- Fetch APIを用いて非同期通信を行い、JSONデータをやり取りしてTodoリストの更新を行うWEBアプリを作成する
- 検索エンジンとの相性の悪さと、初期表示の遅さというデメリットを解消するために、SSRという仕組みが用いられる

#### 8.WEB API
- RESTという概念では、コンテンツに含まれるそれぞれのデータ要素をリソースとして捉え、
URLと紐付ける
- WEB APIでは、CRUDという概念が用いられる
- ブラウザには、デフォルトで同一オリジンポリシーが適用されているため、WEB APIを実装する上では、CORSという手法を用いて、クロスオリジン制限を回避する必要がある
- GraphQLは、クライアントから欲しいデータの形式を指定することにより、APIの粒度が小さくなってしまうRESTful APIのN+1問題を解消することができる

#### 9.サーバープッシュ技術
- SSEは、サーバーサイドプッシュを実現するための技術の1つであり、データをチャンクに分けてクライアントからリクエストを送ることで、ポーリングによる通信量を削減することができる
- WebSocketは、大量のデータを双方向に送受信する必要需要の増加に伴い生まれ、クライアントとサーバーの双方向のデータの送信を可能にする


---

## ❓ 不明点・疑問点

### デベロッパーツールのNetworkタブのTypeが何を表しているか

#### 🔸 具体的にどの部分がわからなかったか
- 同上

#### 🔸 どのように解消したか
- ChatGPT
- 主な Type の種類と意味

| Type       | 意味                                          |
|------------|---------------------------------------------------------------|
| document   | HTML ドキュメント（ページ本体）                                    |
| script     | JavaScript ファイル                                            |
| stylesheet | CSS ファイル                                                   |
| image      | 画像ファイル（png, jpg, gif, webp など）                         |
| font       | Webフォント（woff, ttf など）                                   |
| xhr        | XMLHttpRequest / XMLHttpRequest API を使った非同期リクエスト      |
| fetch      | fetch() API による非同期リクエスト（xhr と似ているが区別される） |
| media      | 動画や音声（mp4, mp3, webm など）                              |
| ws         | WebSocket 通信                                                 |
| other      | 上記に分類できないその他のリソース                              |

### http.ResponseWriterの構造

#### 🔸 具体的にどの部分がわからなかったか
- http.ResponseWriterインターフェースの中身がわからなかった。


#### 🔸 どのように解消したか
- ChatGPT
``` go
type ResponseWriter interface {
    Header() http.Header// レスポンスヘッダを操作する
    Write([]byte) (int, error)  //レスポンスボディを書き込む
    WriteHeader(statusCode int)  //HTTPステータスコードを設定する
}
```

### http.Requestの構造

#### 🔸 具体的にどの部分がわからなかったか
- http.Request構造体の全体構成がわからなかった。

#### 🔸 どのように解消したか
- ChatGPT
```go
type Request struct {
    Method string        // "GET", "POST", "PUT" など
    URL    *url.URL      // リクエスト先の URL (パスやクエリ含む)
    Header Header        // リクエストヘッダ
    Body   io.ReadCloser // リクエストボディ（POSTデータなど）

    ContentLength int64
    Host          string
    Form          url.Values
    PostForm      url.Values
    MultipartForm *multipart.Form
    Cookie        []*Cookie

    RemoteAddr string
    ...
}
```

### postメソッドにおけるフォームデータとレスポンスボディの違いと使い分け

#### 🔸 具体的にどの部分がわからなかったか
- 定義と使い分け

#### 🔸 どのように解消したか
- ChatGPT

✅ 1. フォームデータ（リクエストの一部）
クライアント → サーバーに送るデータ
HTTP リクエストの ボディ部分に格納される
主に **ユーザー入力（フォーム送信やAPIの入力）**を送るために使う

✅ 2. レスポンスボディ（レスポンスの一部）
サーバー → クライアントに返すデータ
HTTP レスポンスの ボディ部分に格納される
主に 処理結果やページ内容を返す

## フロントエンドのフレームワークを利用するメリット

#### 🔸 具体的にどの部分がわからなかったか
- 同上

#### 🔸 解消手段・解消結果
- ChatGPT
## React / Vue などフレームワークを使う場合

 ✅ メリット
- **宣言的 UI**  
  → 「データがこうなったら UI はこうなる」と書けるので、DOM 更新処理を自分で書く必要がない。  
- **コンポーネント再利用**  
  → ボタン、フォーム、カードなどを部品化し、再利用可能。  
- **状態管理が楽**  
  → React の `useState`、Vue の `ref` / `reactive` などで UI とデータを同期できる。  
- **エコシステムが豊富**  
  → ルーティング、状態管理、テストツールなどが揃っている。  
- **保守性が高い**  
  → 大規模開発に向いている。チームで分業もしやすい。  

 ❌ デメリット
- **学習コスト**  
  → JSX, hooks, Vue の reactivity など新しい概念を覚える必要あり。  
- **バンドルサイズが大きい**  
  → 小さなページでも数百 KB の JS が必要になることも。  
- **過剰な場合がある**  
  → 小さなアプリでは「大砲で蚊を撃つ」状態になる。  
- **検索エンジンとの相性が悪い**
  →SEO対策で不利になる。(SSRなどの対策が必要) URLにフラグメントが含まれているページは検索できない。

## JavaScriptにおけるlocationオブジェクトの中身

#### 🔸 具体的にどの部分がわからなかったか
- 同上

#### 🔸 解消手段・解消結果
- ChatGPT
| プロパティ | 例 (`https://example.com:8080/path/page.html?id=123#section`) | 説明 |
|------------|-----------------------------------------------------------|------|
|`href`|`https://example.com:8080/path/page.html?id=123#section`| ページ全体の URL |
| `protocol` | `https:`                                   | 使用しているプロトコル |
| `host`     | `example.com:8080`                            | ホスト名 + ポート番号 |
| `hostname` | `example.com`                                | ホスト名のみ |
| `port`     | `8080`                                       | ポート番号 |
| `pathname` | `/path/page.html`                             | パス部分 |
| `search`   | `?id=123`                                 | クエリ文字列（`?` 含む） |
| `hash`     | `#section`                           | フラグメント（ページ内アンカー） |
| `origin`   | `https://example.com:8080`          | プロトコル + ホスト名 + ポート |


## フラグメント方式とHistoryAPI方式の違い

#### 🔸 具体的にどの部分がわからなかったか
- どちらがどのようにメリット・デメリットがあるのか

#### 🔸 解消手段・解消結果
- ChatGPT

✅ 1. フラグメント方式（Hash Routing）
URL の #（フラグメント、アンカー）を利用してページを切り替える。
例:https://example.com/#/page1
フラグメント部分はサーバーには送信されず、ブラウザだけが扱う。
JavaScript が window.onhashchange を監視して、画面を切り替える。

<特徴>
サーバー側の設定が不要（どの URL にアクセスしても /index.html を返す必要がない）
古いブラウザでも動作する
ただし URL に # が入るため、見た目や SEO の観点でやや不利

✅ 2. History API 方式
HTML5 で追加された history.pushState() と history.popstate を利用。
例:https://example.com/page1
実際にはページ遷移せず、アドレスバーだけ書き換えて JavaScript が画面を差し替える。

<特徴>
URL が自然（サーバー側ルーティングと同じ見た目）
SEO に有利（Google などの検索エンジンはクリーンな URL を評価しやすい）
ただしサーバー側に「どのパスにアクセスしても index.html を返す」設定（history API fallback）が必要


## ステートレスとステートフルの違いについて

#### 🔸 具体的にどの部分がわからなかったか
- メリット・デメリット、利用シーン

#### 🔸 解消手段・解消結果
- ChatGPT

✅ ステートレス（Stateless）

- 特徴

サーバーが「クライアントの状態（ログイン情報や進行状況など）」を保持しない。
各リクエストは独立していて、必要な情報は毎回クライアントから送る。
HTTP が典型的なステートレスプロトコル。
- メリット

スケーラブル：サーバーを増やしてもセッション情報を気にせず処理できる。
シンプル：サーバー側の設計が簡単、セッション管理不要。
障害耐性が高い：あるサーバーが落ちても、他のサーバーに切り替えやすい。

- デメリット

毎回情報を送る必要がある → ネットワーク負荷やデータサイズが増える。
文脈を理解しづらい → 例えば「前回ログインしていたユーザー」などを覚えていない。

- 利用シーン

REST API（基本的にすべてステートレス設計）
CDN や負荷分散を使う大規模 Web サービス
スケーラブルにしたいマイクロサービス

✅ ステートフル（Stateful）
- 特徴

サーバーやシステムが「クライアントの状態」を保持する。
一度確立した接続に対して文脈が維持される。
例：ログインセッション、チャットの接続、データベース接続。

- メリット

連続性がある：ユーザーが一度ログインすれば次の操作は省略できる。
効率的：毎回フル情報を送らずに済む。
リッチな体験：リアルタイム通信（WebSocket）などに向く。

- デメリット

サーバーの負担が大きい：接続やセッションを保持し続ける必要がある。
スケーリングが難しい：セッションをどのサーバーが持つか管理が必要。
障害耐性が低い：担当サーバーが落ちるとセッションも消える可能性がある。

- 利用シーン

ログインやユーザーごとの文脈が必須なサービス（ECサイトのカートなど）
リアルタイム通信（オンラインゲーム、チャット、WebSocket API）
長時間の接続を前提とした処理（ストリーミング）


## ユーザー認証の種類と使い分けについて

#### 🔸 具体的にどの部分がわからなかったか
- メリット・デメリット、利用シーン

#### 🔸 解消手段・解消結果
- ChatGPT


## システムをステートレスにするための認証方法にはどのような選択肢があるか

#### 🔸 具体的にどの部分がわからなかったか
- 各認証の種類・使い分け

#### 🔸 解消手段・解消結果
- ChatGPT

##### 1. アクセストークン（JWTなど）
- 認証後に署名付きトークンを払い出し、毎回リクエストで提示。  
- サーバーは署名検証だけでユーザー識別できる。  
👉 一般的な **OAuth2 / OIDC** の仕組み。  

---

##### 2. APIキー（固定トークン）
- 各クライアントに **一意のランダムキー**を発行してリクエストに含める。  
- サーバーはキーの正当性チェックだけ行う（DB or キャッシュに照会）。  
- サーバー側に「ログイン状態」は保持しないのでステートレス。  
👉 「ユーザー認証」よりも **アプリ認証・機械間通信**で利用されることが多い。  

---

##### 3. 署名付きリクエスト（HMAC署名）
- AWS S3 の **Signature v4 認証**などの方式。  
- リクエストごとに **秘密鍵＋リクエスト内容で HMAC 署名**をつける。  
- サーバーは署名検証だけで正当性を判断。  
👉 毎回リクエスト自体に認証情報が含まれるためステートレス。  

---

##### 4. mTLS（相互TLS）
- 通信確立時に **クライアント証明書**で相互認証。  
- セッションIDは不要で、証明書自体が認証手段になる。  
- サーバーは「この証明書が信頼済み CA から発行されているか」だけ確認すればよい。  
👉 **B2B API** や **内部システム間通信**に強力。  

---

##### 5. 署名付きURL（一時URL）
- S3 Presigned URL のように、リソースごとに **署名＋有効期限**を含めた URL を発行。  
- リクエストには認証ヘッダー不要。  
- サーバーは署名の妥当性検証だけを行う。  
👉 **ファイル配布**など「限定的アクセス」に適している。  

---

##### 6. パスキー / WebAuthn（公開鍵認証）
- 認証情報（公開鍵）はサーバーに登録済み。  
- 各リクエストで **署名チャレンジ**を検証するだけでよい。  
👉 ユーザー認証として使えば、**セッションを持たずにリクエスト単位で安全に本人確認**が可能。  



## http.MethodGetについて

#### 🔸 具体的にどの部分がわからなかったか
- 変数なのかパッケージなのか、何を表しているのか

#### 🔸 解消手段・解消結果
- ChatGPT
```go
const (
    MethodGet     = "GET"
    MethodHead    = "HEAD"
    MethodPost    = "POST"
    MethodPut     = "PUT"
    MethodPatch   = "PATCH" // RFC 5789
    MethodDelete  = "DELETE"
    MethodConnect = "CONNECT"
    MethodOptions = "OPTIONS"
    MethodTrace   = "TRACE"
)
```


## クロスオリジン通信が危険な理由

#### 🔸 具体的にどの部分がわからなかったか
- なぜ危険なのか

#### 🔸 解消手段・解消結果
- ChatGPT
##### 1. CSRF（クロスサイトリクエストフォージェリ）の危険
- ブラウザの JavaScript が任意のオリジンに自由にリクエストでき、Cookie も自動送信されると危険。
- 悪意あるサイト `evil.com` がユーザーのブラウザで実行されると：
  - ユーザーがログイン中の `bank.com` に勝手にリクエスト可能。
  - セッション Cookie も自動送信される。
  - **勝手に送金や設定変更が行われるリスク**。

---

##### 2. XSS（クロスサイトスクリプティング）の被害拡大
- 悪意のスクリプトが入り込むと、自由に他オリジンへアクセス可能。
- 例：悪意サイトが `https://mail.example.com` へリクエストし、メールを盗み見る。

---

##### 3. プライバシー流出
- 異なるオリジンから勝手にデータを読めると危険。
- ユーザーの行動やアカウント情報が**第三者に漏れる可能性**がある。


### クロスオリジン通信が危険な理由

#### 🔸 具体的にどの部分がわからなかったか
- なぜ危険なのか

#### 🔸 解消手段・解消結果
- ChatGPT

<ブラウザ側の管理>
- ブラウザは **ホワイトリストを持っていない**。  
- ルールは **同一オリジンポリシー（SOP）** で統一されている。  
- クロスオリジン通信を例外的に許可するかどうかは、**サーバーが返すレスポンスヘッダ**で決まる。  
- ブラウザはレスポンスを検証し、「このオリジンは許可されているか？」を**その都度判断**する。  


### GraphQLを用いるメリット

#### 🔸 具体的にどの部分がわからなかったか
- GraphQLの仕組み・利用シーン

#### 🔸 解消手段・解消結果
- ChatGPT
##### ✅ 背景：REST API の課題
従来の REST API では、サーバーが固定の形でデータを返す仕組みになっています。
そのため、以下のような問題が発生します。
##### Over-fetching（取りすぎ問題）
- `/user/1` を叩くと、必要なのは `name` だけなのに、住所や電話番号など **不要なデータまで返ってくる**。
- 結果として、**ネットワーク負荷やレスポンスサイズが大きくなる**。
##### Under-fetching（取り足りない問題）
- `/user/1` で `name` は取れるが、`posts` も必要なら `/user/1/posts` を追加で叩く必要がある。
- **複数リクエストが必要になり、通信回数が増えて遅くなる**。



---

## 💡 その他気づいたこと
- イベントドリブンプログラミングでは、イベントループをOSやミドルウェア、フレームワークが担当している→フレームワークの利点の1つ

---

## 🛠️ コンテンツの改善点
- 特にないが、一部のソースコードにおいて、JavaScriptなどにあまり馴染みのない方にとってはコードの理解に時間がかかってしまうように感じたため、必要に応じて他のコンテンツで埋める必要があると感じた。
- コードを作成するというよりは、どちらかというとコードを読むという前提で進む部分がほとんどなので、実際にコードを書いて理解することができるとさらに理解が深まるのではないかと感じた。


