# 📌 タイトル
- ［改訂新版］プロになるためのWeb技術入門

---

## 💼 業務で活かす場面
- フロントエンドアプリケーションの構築

---

## 🎯 学習目的
- 

---

## 📝 全体の感想
- （学習してみて感じたことを自由に記載）

---

## 📖 内容の要約
- （理解した内容を簡潔にまとめる）

---

## ❓ 不明点・疑問点

### デベロッパーツールのNetworkタブのTypeが何を表しているか

#### 🔸 具体的にどの部分がわからなかったか
- 同上

#### 🔸 どのように解消したか
- ChatGPT
- 主な Type の種類と意味

| Type       | 意味                                          |
|------------|---------------------------------------------------------------|
| document   | HTML ドキュメント（ページ本体）                                    |
| script     | JavaScript ファイル                                            |
| stylesheet | CSS ファイル                                                   |
| image      | 画像ファイル（png, jpg, gif, webp など）                         |
| font       | Webフォント（woff, ttf など）                                   |
| xhr        | XMLHttpRequest / XMLHttpRequest API を使った非同期リクエスト      |
| fetch      | fetch() API による非同期リクエスト（xhr と似ているが区別される） |
| media      | 動画や音声（mp4, mp3, webm など）                              |
| ws         | WebSocket 通信                                                 |
| other      | 上記に分類できないその他のリソース                              |

### http.ResponseWriterの構造

#### 🔸 具体的にどの部分がわからなかったか
- http.ResponseWriterインターフェースの中身がわからなかった。


#### 🔸 どのように解消したか
- ChatGPT
``` go
type ResponseWriter interface {
    Header() http.Header// レスポンスヘッダを操作する
    Write([]byte) (int, error)  //レスポンスボディを書き込む
    WriteHeader(statusCode int)  //HTTPステータスコードを設定する
}
```

### http.Requestの構造

#### 🔸 具体的にどの部分がわからなかったか
- http.Request構造体の全体構成がわからなかった。

#### 🔸 どのように解消したか
- ChatGPT
```go
type Request struct {
    Method string        // "GET", "POST", "PUT" など
    URL    *url.URL      // リクエスト先の URL (パスやクエリ含む)
    Header Header        // リクエストヘッダ
    Body   io.ReadCloser // リクエストボディ（POSTデータなど）

    ContentLength int64
    Host          string
    Form          url.Values
    PostForm      url.Values
    MultipartForm *multipart.Form
    Cookie        []*Cookie

    RemoteAddr string
    ...
}
```

### postメソッドにおけるフォームデータとレスポンスボディの違いと使い分け

#### 🔸 具体的にどの部分がわからなかったか
- 定義と使い分け

#### 🔸 どのように解消したか
- ChatGPT

✅ 1. フォームデータ（リクエストの一部）
クライアント → サーバーに送るデータ
HTTP リクエストの ボディ部分に格納される
主に **ユーザー入力（フォーム送信やAPIの入力）**を送るために使う

✅ 2. レスポンスボディ（レスポンスの一部）
サーバー → クライアントに返すデータ
HTTP レスポンスの ボディ部分に格納される
主に 処理結果やページ内容を返す

## フロントエンドのフレームワークを利用するメリット

#### 🔸 具体的にどの部分がわからなかったか
- 同上

#### 🔸 解消手段・解消結果
- ChatGPT
## React / Vue などフレームワークを使う場合

 ✅ メリット
- **宣言的 UI**  
  → 「データがこうなったら UI はこうなる」と書けるので、DOM 更新処理を自分で書く必要がない。  
- **コンポーネント再利用**  
  → ボタン、フォーム、カードなどを部品化し、再利用可能。  
- **状態管理が楽**  
  → React の `useState`、Vue の `ref` / `reactive` などで UI とデータを同期できる。  
- **エコシステムが豊富**  
  → ルーティング、状態管理、テストツールなどが揃っている。  
- **保守性が高い**  
  → 大規模開発に向いている。チームで分業もしやすい。  

 ❌ デメリット
- **学習コスト**  
  → JSX, hooks, Vue の reactivity など新しい概念を覚える必要あり。  
- **バンドルサイズが大きい**  
  → 小さなページでも数百 KB の JS が必要になることも。  
- **過剰な場合がある**  
  → 小さなアプリでは「大砲で蚊を撃つ」状態になる。  
- **検索エンジンとの相性が悪い**
  →SEO対策で不利になる。(SSRなどの対策が必要) URLにフラグメントが含まれているページは検索できない。

## JavaScriptにおけるlocationオブジェクトの中身

#### 🔸 具体的にどの部分がわからなかったか
- 同上

#### 🔸 解消手段・解消結果
- ChatGPT
| プロパティ | 例 (`https://example.com:8080/path/page.html?id=123#section`) | 説明 |
|------------|-----------------------------------------------------------|------|
|`href`|`https://example.com:8080/path/page.html?id=123#section`| ページ全体の URL |
| `protocol` | `https:`                                   | 使用しているプロトコル |
| `host`     | `example.com:8080`                            | ホスト名 + ポート番号 |
| `hostname` | `example.com`                                | ホスト名のみ |
| `port`     | `8080`                                       | ポート番号 |
| `pathname` | `/path/page.html`                             | パス部分 |
| `search`   | `?id=123`                                 | クエリ文字列（`?` 含む） |
| `hash`     | `#section`                           | フラグメント（ページ内アンカー） |
| `origin`   | `https://example.com:8080`          | プロトコル + ホスト名 + ポート |


## フラグメント方式とHistoryAPI方式の違い

#### 🔸 具体的にどの部分がわからなかったか
- どちらがどのようにメリット・デメリットがあるのか

#### 🔸 解消手段・解消結果
- ChatGPT

✅ 1. フラグメント方式（Hash Routing）
URL の #（フラグメント、アンカー）を利用してページを切り替える。
例:https://example.com/#/page1
フラグメント部分はサーバーには送信されず、ブラウザだけが扱う。
JavaScript が window.onhashchange を監視して、画面を切り替える。

<特徴>
サーバー側の設定が不要（どの URL にアクセスしても /index.html を返す必要がない）
古いブラウザでも動作する
ただし URL に # が入るため、見た目や SEO の観点でやや不利

✅ 2. History API 方式
HTML5 で追加された history.pushState() と history.popstate を利用。
例:https://example.com/page1
実際にはページ遷移せず、アドレスバーだけ書き換えて JavaScript が画面を差し替える。

<特徴>
URL が自然（サーバー側ルーティングと同じ見た目）
SEO に有利（Google などの検索エンジンはクリーンな URL を評価しやすい）
ただしサーバー側に「どのパスにアクセスしても index.html を返す」設定（history API fallback）が必要


## ステートレスとステートフルの違いについて

#### 🔸 具体的にどの部分がわからなかったか
- メリット・デメリット、利用シーン

#### 🔸 解消手段・解消結果
- ChatGPT

✅ ステートレス（Stateless）

- 特徴

サーバーが「クライアントの状態（ログイン情報や進行状況など）」を保持しない。
各リクエストは独立していて、必要な情報は毎回クライアントから送る。
HTTP が典型的なステートレスプロトコル。
- メリット

スケーラブル：サーバーを増やしてもセッション情報を気にせず処理できる。
シンプル：サーバー側の設計が簡単、セッション管理不要。
障害耐性が高い：あるサーバーが落ちても、他のサーバーに切り替えやすい。

- デメリット

毎回情報を送る必要がある → ネットワーク負荷やデータサイズが増える。
文脈を理解しづらい → 例えば「前回ログインしていたユーザー」などを覚えていない。

- 利用シーン

REST API（基本的にすべてステートレス設計）
CDN や負荷分散を使う大規模 Web サービス
スケーラブルにしたいマイクロサービス

✅ ステートフル（Stateful）
- 特徴

サーバーやシステムが「クライアントの状態」を保持する。
一度確立した接続に対して文脈が維持される。
例：ログインセッション、チャットの接続、データベース接続。

- メリット

連続性がある：ユーザーが一度ログインすれば次の操作は省略できる。
効率的：毎回フル情報を送らずに済む。
リッチな体験：リアルタイム通信（WebSocket）などに向く。

- デメリット

サーバーの負担が大きい：接続やセッションを保持し続ける必要がある。
スケーリングが難しい：セッションをどのサーバーが持つか管理が必要。
障害耐性が低い：担当サーバーが落ちるとセッションも消える可能性がある。

- 利用シーン

ログインやユーザーごとの文脈が必須なサービス（ECサイトのカートなど）
リアルタイム通信（オンラインゲーム、チャット、WebSocket API）
長時間の接続を前提とした処理（ストリーミング）


## ユーザー認証の種類と使い分けについて

#### 🔸 具体的にどの部分がわからなかったか
- メリット・デメリット、利用シーン

#### 🔸 解消手段・解消結果
- ChatGPT



---

## 💡 その他気づいたこと
- イベントドリブンプログラミングでは、イベントループをOSやミドルウェア、フレームワークが担当している→フレームワークの利点の1つ

---

## 🛠️ コンテンツの改善点
- （改善してほしい点、補足してほしい情報など）



