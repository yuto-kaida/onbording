## コミット名
- repositoryの追加

### 作業目標・指示
#### 2. 永続化機能の追加
`interface/repository/employee.go`を作成し、modelの永続化機能を実装する。
docker内に入り、`go run ./cmd/try.go`を呼び出すことで、実行結果を確認できる。

#### 課題
1. select文が実行できるコードを追加して動作確認を行い、教育担当者へ実装完了の証明をする。
   なお、selectはemployeeIdを指定して取得するものとし、interfaceに追加する関数名は`FindById`とする。
2. update文が実行できるコードを追加して動作確認を行い、教育担当者へ実装完了の証明をする。
   なお、updateはemployeeIdを用いて一意のレコードを指定し、単一のレコードの全てのカラムのデータを更新する仕様とする。


---

### 作業概要
1. 作業名
...

#### 1.作業名
1. ...
...

---

###　作業結果

#### 確認方法
1. 確認方法1
...

#### 確認結果
- 確認結果



---

## ❓ 不明点・疑問点

### Goでインターフェースを実装した後に、再びインターフェースに代入する目的

#### 🔸 質問内容
- Goにおいて、インターフェースの機能は既に引き継いでいるのに、インターフェースの実装後にインターフェースそのものに代入する目的は何なのでしょうか

#### 🔸 質問方法・回答
- ChatGPT
###### ✅ 主な目的

1. **抽象化による柔軟性**
   - 具体的な型に依存せず、共通のインターフェースで扱えるようにする。
   - 例: `fmt.Println` は `io.Writer` インターフェースに書き込むが、その実体は `os.Stdout`（ファイル）、`bytes.Buffer`（メモリバッファ）など様々に差し替え可能。

   ```go
   func PrintMessage(w io.Writer, msg string) {
       w.Write([]byte(msg))
   }

   // 呼び出し側では色々渡せる
   PrintMessage(os.Stdout, "Hello")       // コンソール出力
   PrintMessage(&bytes.Buffer{}, "Hello") // メモリに書き込み
   ```

   👉 呼び出し側は「`io.Writer` を持っている」ことだけを気にすればよく、実装を意識しなくて済む。

---

2. **依存性の逆転（テストや拡張に有効）**
   - 実装を直接持たずにインターフェース経由で利用することで、テスト時にモックを差し替え可能。
   ```go
   type DB interface {
       FindUser(id int) string
   }

   type RealDB struct{}
   func (RealDB) FindUser(id int) string { return "Alice" }

   type MockDB struct{}
   func (MockDB) FindUser(id int) string { return "TestUser" }

   func GetUserName(db DB, id int) string {
       return db.FindUser(id)
   }
   ```

   👉 本番は `RealDB` を渡し、テストは `MockDB` を渡すだけでテスト容易性が向上。

---

3. **多態性（Polymorphism）**
   - 複数の異なる型を一つのインターフェース型にまとめられる。
   ```go
   type Shape interface {
       Area() float64
   }

   type Circle struct{ R float64 }
   func (c Circle) Area() float64 { return 3.14 * c.R * c.R }

   type Rectangle struct{ W, H float64 }
   func (r Rectangle) Area() float64 { return r.W * r.H }

   func PrintArea(s Shape) {
       fmt.Println("Area:", s.Area())
   }

   func main() {
       PrintArea(Circle{R: 5})
       PrintArea(Rectangle{W: 3, H: 4})
   }
   ```

   👉 `Circle` と `Rectangle` は違う型だが、`Shape` インターフェースに代入して共通処理できる。

---

##### まとめ
- インターフェースに代入する目的は、  
  1. **抽象化**して具体型に依存しないようにする  
  2. **差し替え可能性**を高め、テストや拡張を容易にする  
  3. **多態性**を実現して異なる型を共通の型として扱う  

👉 言い換えると、**「型が持つ機能を、そのままではなく“契約（interface）”として扱うことで、設計の柔軟性を得る」** のが目的です。  

---


## 💡 その他気づいたこと
- 

---




