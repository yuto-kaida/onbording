# 📌 タイトル
- サバイバルTypeScript

---

## 💼 業務で活かす場面
- フロントエンド、バックエンドアプリケーションの開発
- 特に堅安全性や、開発時のバグ早期発見を目的とした実装時

---

## 🎯 学習目的
- 実装方法の理解

---

## 📝 全体の感想
- 全体的に説明が固め(大学の教科書のよう)でわかりにくく、理解するのに労力を要する。文章をそのまま読んでもスッと入ってこない部分が多々あり、ChatGPTに改めて質問を投げて理解する時間が大変だった。その結果、知っていた知識であったというケースもいくつかあった。
- 定義がほとんど同じで似たようなオブジェクトや型などの概念が多く、違いを理解することに苦労した
- インプット量が多く一気に詰め込んでも飽和してしまう可能性が高いため、実務に沿って優先度付けを行うとよりインプットしやすくなると感じた
- 作って学ぶTypeScriptでは、学んだことを活せる部分は多くないものの、デプロイを体験するという観点においては、内容量もちょうどよく、アウトプットの場として良い機会になると感じた。

---

## 📖 内容の要約

### 全体構成
- TypeScriptのあらまし
- 作って学ぶTypeScript
- 読んで学ぶTypeScript


#### TypeScriptのあらまし
- TypeScriptは、JavaScriptをベースとして、静的型付け、型推論、高度な型表現などの特徴を持つ言語である
- TypeScriptの実行時パフォーマンスはJavaScriptと同じだが、TypeScriptにランタイムは存在しない

#### 読んで学ぶTypeScript

##### 値・型・変数
- オブジェクト、配列を不変にするにはreadonlyプロパティが必要
- varは、既存変数(グローバル変数を含む)を上書きすることができてしまう
- varのスコープは関数であり、制御構文はスコープ外
- JSのnumber型は、-(2^53 − 1)から2^53 − 1の範囲の倍精度浮動小数である
- Symbol型では、値が同じであっても初期化した場所が異なっていれば異なる値として扱われる
- TSは、ラッパーオブジェクト型とプリミティブ型を識別する
- TSにおいて、プリミティブ以外はなんでもオブジェクトになる。オブジェクトリテラルとの違いは、直接{}を使って書かれているかどうか
- TypeScriptは構造的片付けを採用している
- enum型はTypeScript独自の型。数値を代入した場合、それに続くメンバーは連番になる
- 判別可能なユニオン型では、各オブジェクトの型を判別するためのプロパティとして、ディスクリミネータを持つ
- const assertionでは、as constをつけることによって、オブジェクト配下の全てのプロパティを固定する
- tsconfig.jsonでstrictNullChecks: true にすると、変数に対して明確な割り当てアサーションが有効になり、strictPropertyInitialization: trueにすると、プロパティに対して...
- === は型も値も等しいことを表す。== は型が異なっても同じとみなすことがある
- 戻り値にvalue is SomeTypeのように記載することで、戻り値の型を保証する関数を、型ガード関数という


##### オブジェクト
- {}型はプロパティを持たないObject型。Object型は、インターフェースで、プリミティブ型も代入できてしまうので、推奨されないため、プリミティブ型を代入できないobject型を用いることが推奨される。
- TypeScriptでオプショナルチェーンを使った場合、得られる値の型は、最後のプロパティの型とundefinedのユニオン型になります。
```ts
let book: undefined | { title: string };
const title = book?.title;
const title: string | undefined
```
- Object.prototypeを変更するとその影響は、このプロトタイプを持つすべてのオブジェクトに影響する
- for in文とfor of文の違いは、キーを走査するか、値そのものを走査するかの違い


##### 配列
- 配列の代入を行うと、代入元の変数と代入先の変数は同じ値を指すため、配列のコピーにはスプレッド構文を使う
```ts
const arr = [1, 2, 3];
const backup = arr;
arr.push(4); // 変更
console.log(arr);
(4) [1, 2, 3, 4]
console.log(backup); // こちらにも影響
(4) [1, 2, 3, 4]
```
- コンパイラーオプションのnoUncheckedIndexedAccessを有効にすると、たとえば、string[]配列から要素アクセスで得た値の型は、string型もしくはundefined型を意味するstring | undefinedになる。また、配列T[]から分割代入するとT型もしくはundefined型を示すT | undefined型になります。
- 読み取り専用配列では、popやpushは使えない
- for-in文で配列をループすることはできるが、この場合順番通りになる保証がない


##### 文
- switch文におけるcaseは連続して書くこともできる
```ts
const food = "🍙";
switch (food) {
  case "🍎":
  case "🍓":
  case "🍉":
    console.log("くだもの");
    break;
  case "🍙":
  case "🍜":
  case "🍞":
    console.log("炭水化物");
    break;

  default:
    console.log("未知の食べ物");
    break;
}
"炭水化物"
```
- switch文では変数スコープが適用されるが、case文では適用されないため、適用する場合は{}で括る必要がある
- コンパイラオプションのuseUnknownInCatchVariablesをtrueにすると、catchの値がanyではなくunknown型となる
- finallyブロックでは、catchが実行されようがされまいが、必ず最後に実行される
- never型は何にも代入できない
- 網羅性チェックを例外(never)にしておくと、未使用変数についてのコンパイルエラーが発生しなくなる
- 特定のクラスのインスタンスを判定したい場合は、typeofではなkじゅinstanceofを利用する


##### 関数
- noImplicitAnyをtrueにすることで、型注釈を必須にできる
- 関数宣言ではなく、関数式を用いた場合は、関数の巻き上げが起こらない
- コンパイラオプションalwaysStrictを有効にすると、コンパイル後のJavaScriptがstrictモードになる
| 文脈 | 呼び出し例 | `this` の値 |
|------|-------------|-------------|
| 通常の呼び出し | `showThis()` | グローバルオブジェクト（ブラウザでは `window`） |
| 通常の呼び出し + strict モード | `showThis()` | `undefined` |
| メソッド呼び出し | `obj.showThis()` | メソッドが属するオブジェクト (`obj`) |
| コンストラクタ呼び出し | `new showThis()` | 生成中の新しいオブジェクト |

- showThis.bind(obj)(); のようにして、関数にバインドすることで、thisが指す対象を指定できる(アロー関数では適用されない)
- 関数はオブジェクトに含まれるため、プロパティを持つことができる
- 戻り値にundefinedを利用した場合、コンパイルエラーが表示されないが、void型を利用した場合、エラーが表示されるため、void型を利用した方が良い
- オブジェクトはどこでも参照になる
- 引数をオプションにする場合は、デフォルト値を代入するか、型に応じて処理を分ける必要がある。
- コンパイラオプションnoUncheckedIndexedAccessを有効にした場合、分割代入引数はundefinedとのユニオン型になる
- TypeScriptでデフォルト引数を型注釈する場合、オブジェクトではプロパティを?でオプションにします。
```ts
function foo({ a = 0 }: { a?: number | string }) {}
```
- 即時実行関数式は非同期で実行される


##### 非同期処理

##### オブジェクト指向
- 複数のインターフェースを宣言してもエラーにならない仕様のことを、オープンエンドといい、同じ名前のインターフェースを宣言した場合、それぞれのインターフェースの型がマージされる。
```ts
interface Foo {
  a: number;
}
interface Foo {
  b: number;
}
```
この宣言は、次のようにプロパティaとプロパティbを持つインターフェースを、ひとつ定義したことと同じことになり、これを宣言マージという。
```ts
interface Foo {
  a: number;
  b: number;
}
```
- インターフェースの判定は、instanceofでは実現できない(型レベルのものは適用されない)t前、型ガード関数を利用する
- インターフェースで継承の際にプロパティをオーバーライドすると、継承元のプロパティが上書きされるが、型エイリアスの場合はフィールドの交差型が計算される


##### JSX
- オブジェクト同士では、==も===も同じ挙動をする



##### モジュール
- モジュールは、機能分割のために作成されたファイルそのものを指し、パッケージは配布用にモジュールをまとめたもの
- importはESモジュールをインポートする際に用いるもので、requireはCommonJSのモジュールをインポートする際に用いる
- exportはESモジュールをインポートする際に用いるもので、module.exportsはCommonJSのモジュールをインポートする際に用いる
- モジュールのコードが評価されるのは、初回のインポート時のみ


##### ジェネリクス
- インターフェースは実装の時はimplementsキーワードを使うが、型引数に使う時はextendsを使う
- 変性はtsconfig.jsonのstrictFunctionTypesの設定でも変更することができる


##### tsconfig
- moduleオプションでは、バックエンドのモジュール読み込み方法はCommonJS、フロントエンドは、es2015, es2020, esnextのいずれかを指定することが望ましい
- strictNullChecksがtrueの場合は、undefinedやnullが戻り値になる可能性をコンパイラが考慮する。
```ts
strictNullChecksがtrueの場合
const result = [1, 2, 3].find((x) => x == 1);
const result: number | undefined
const element = document.getElementById("main");
const element: HTMLElement | null
```
- switch文におけるcase文でbreakまたはreturnを行わないことをfallthroughという


##### 型定義ファイル
- namespaceを使用することで、変数や型名のスコープをモジュール内に限定し、グローバル変数との衝突を回避できる
- 













---

## ❓ 不明点・疑問点

### JSとTSにおけるnullとundefinedの違い

#### 🔸 具体的にどの部分がわからなかったか
- 定義の違い

#### 🔸 解消方法・結果
- ChatGPT

##### `undefined(変数)`
- **「値がまだ代入されていない」状態**
- 主なケース
  - 変数を宣言しただけで初期化していない場合
  - オブジェクトのプロパティが存在しない場合
  - 関数の戻り値を明示しない場合

##### `null(リテラル)`
- **「値が存在しないことを明示的に示す」状態**
- 主なケース
  - 開発者が「ここは空です」と意図して代入する場合


### bigint型が表現可能な範囲

#### 🔸 具体的にどの部分がわからなかったか
- 同上

#### 🔸 解消方法・結果
- ChatGPT
- メモリが許す限り実質的に無限だが、ただし実装（V8 エンジンなど）では、数千〜数百万桁くらいまでは問題なく扱えるとされている


### オブジェクトとオブジェクトリテラルの違い

#### 🔸 具体的にどの部分がわからなかったか
- 定義や使い方の違い

#### 🔸 解消方法・結果
- ChatGPT

オブジェクトリテラルに対しては、TypeScript は 余計なプロパティがないか厳密にチェックします。
```ts
type Person = { name: string };
const a: Person = { name: "Taro", age: 25 }; // ❌ エラー（余分なプロパティ）
```
一方、変数経由なら通ってしまう：
```ts
const tmp = { name: "Taro", age: 25 };
const b: Person = tmp; // ✅ OK
```
TypeScript では **構造的型付け** を採用しており、  
「そのオブジェクトが型の要件を満たしているか」だけを見て代入可能かどうかを判断します。

```ts
type Person = { name: string };

const tmp = { name: "Taro", age: 25 };
const b: Person = tmp;
// ✅ OK （構造的には { name: string } を満たしているため）
```

### オブジェクト型とRecord型の違い

#### 🔸 具体的にどの部分がわからなかったか
- 定義や使い方の違い

#### 🔸 解消方法・結果
- ChatGPT
##### 🔹 例1: `Record` でキー集合を必須にする

```ts
type UserNames = "Taro" | "Hanako";

type UserAges = Record<UserNames, number>;

const ages: UserAges = {
  Taro: 25,
  Hanako: 30,
  // Jiro: 40, // ❌ エラー: "Jiro" は定義されていない
};
```
Record<UserNames, number> は
「Taro」と「Hanako」というキーを必ず持ち、値は number」 という意味。片方を省略するとエラーになる。

##### 例2: オブジェクト型（インデックスシグネチャ）の場合
```ts
type UserAgesObj = {
  [key: string]: number;
};

const ages: UserAgesObj = {
  Taro: 25,
  Hanako: 30,
};

// 実は片方なくてもOK
const ages2: UserAgesObj = {
  Taro: 25,
};
// ✅ エラーにならない
```
[key: string]: number は
「任意の文字列キーを持つかもしれないオブジェクト」 を表す。
したがって「必ずこのキーがある」ことは保証できない。

ただし、インデックス型はRecord<K, T>ユーティリティ型と同義
```ts
let obj1: { [K: string]: number };
let obj2: Record<string, number>;
```


### オブジェクト型のオプションプロパティの意味

#### 🔸 具体的にどの部分がわからなかったか
- 定義や使い方の違い

#### 🔸 解消方法・結果
- ChatGPT
# TypeScript におけるオブジェクト型（インデックスシグネチャ）とオプションプロパティの違い

##### 🔹 オブジェクト型（インデックスシグネチャ）の場合
```ts
type UserAges = {
  [key: string]: number;
};
const ages1: UserAges = { Taro: 25 };             // ✅ OK
const ages2: UserAges = { Taro: 25, Hanako: 30 }; // ✅ OK
```
この型は 「任意の文字列キーを持ってよい」 という意味。
具体的にどのプロパティが存在するかは制約していない。
👉 「あるキーがなくてもエラーにならない」のは、**「そもそも型定義でキーが固定されていない」**から。

##### 🔹 オプションプロパティ（?）の意味
```ts
type Person = {
  name: string;
  age?: number;
};
const p1: Person = { name: "Taro" };               // ✅ OK（age は省略可能）
const p2: Person = { name: "Hanako", age: 30 };    // ✅ OK
```
age?: number は
「このプロパティは存在してもよいし、省略されてもよい」 という意味を明示する。
キー集合は固定されるため、余計なプロパティを追加するとエラーになる。

しかし、
```ts
let onlyX: { x: number };
onlyX = { x: 1 }; // OK
onlyX = { x: 1, y: 2 };
```
上記のようなケースは余剰プロパティチェックが働いてエラーになる


### 分割代入の種類

#### 🔸 具体的にどの部分がわからなかったか
- どのような種類が存在するのか

#### 🔸 解消方法・結果
- ChatGPT
##### 入れ子構造の分割代入と変数名の指定
入れ子構造の分割代入をしながら、値を代入する変数名を指定することを同時にすることもできます。
```ts
const continent = {
  name: "北アメリカ",
  us: {
    name: "アメリカ合衆国",
    capitalCity: "ワシントンD.C.",
  },
};

const {
  name: continentName,
  us: { name: countryName },
} = continent;

console.log(continentName);
"北アメリカ"
console.log(countryName);
"アメリカ合衆国"
```

##### 分割代入のデフォルト値
分割代入では、=のあとにデフォルト値が指定できます。デフォルト値は値が、undefinedのときに代入されます。
```ts
const color = { r: undefined, g: 122, b: 204 };
const { r:red = 0, g = 0, b = 0 } = color;
console.log(r, g, b);
0,  122,  204
```
値がnullのときは、デフォルト値が使われません。nullがそのまま代入されます。


### 構造的部分型と名前的部分型の違い

#### 🔸 具体的にどの部分がわからなかったか
- 同上

#### 🔸 解消方法・結果
- ChatGPT
##### 🔹 名前的部分型（Nominal Subtyping）
「型の名前（宣言）そのもの」に基づいて互換性を判断する方式
たとえ構造が同じでも「別の型として宣言されていれば代入できない」
例（JavaやC#など多くのOOP言語がこの方式）:
```ts
class Person {
  String name;
}
class Animal {
  String name;
}
```
Person p = new Animal(); // ❌ コンパイルエラー
👉 Person と Animal は構造が同じでも名前が違うため、互換性なし。

##### 🔹 構造的部分型（Structural Subtyping）
「型の構造（持っているプロパティやメソッド）」に基づいて互換性を判断する方式
名前が違っても、必要な構造を満たしていれば代入可能
TypeScript はこの 構造的部分型 を採用しています。
```ts
type Person = { name: string };
type Animal = { name: string };

const animal: Animal = { name: "Pochi" };
const person: Person = animal; // ✅ OK（構造が同じ）
```
👉 「Person には name: string が必要 → Animal も持っている → 代入可能」と判断される。
構造的には同じであっても型と型を区別する場合にはブランド型(公称型をTypeScriptに導入した型)を用いる
```ts
interface UserId {
  __brand: "UserId";
  id: number;
}
interface ProductId {
  __brand: "ProductId";
  id: number;
}
```
→上記は名前によって区別される


### 配列の分割代入

#### 🔸 具体的にどの部分がわからなかったか
- どのような種類があるのかと、それらの違い

#### 🔸 解消方法・結果
- ChatGPT
##### ネストした配列の分割代入
JavaScriptの分割代入はフラットな配列だけでなく、ネストした入れ子構造の配列からも要素を抽出できます。ネストした要素の分割代入の書き方は、ネスト構造と一致するようにブラケット([ ])を重ねます。
```ts
const twoByTwo = [
  [1, 2],
  [3, 4],
];
const [[one, two], [three]] = twoByTwo;
console.log(one);
1
console.log(two);
2
console.log(three);
3
```

##### 途中要素の分割代入
配列の分割代入は先頭からでなく、途中の要素を取り出すこともできます。その場合、取り出さない要素の数だけカンマを書きます。
```ts
const oneToFive = [1, 2, 3, 4, 5];
const [, , , four, five] = oneToFive;
console.log(four);
4
console.log(five);
5
```


### 型アサーションは、どの範囲まで型をキャストしてしまうのか

#### 🔸 具体的にどの部分がわからなかったか
- どこまで型の変更を許容するのか

#### 🔸 解消方法・結果
- ChatGPT
##### 型アサーションの基本ルール
TypeScript では、型アサーションは 互換性のある型同士でのみ許可されます。
具体的には：
広い型 → 狭い型（ダウンキャスト）は可能
```ts
const value: unknown = "hello";
const str = value as string; // ✅ OK
```
狭い型 → 広い型（アップキャスト）も可能
```ts
const str = "hello";
const value = str as unknown; // ✅ OK
```
互換性のない型同士は直接アサーションできない
```ts
const num = 123;
const str = num as string; // ❌ エラー
```

##### 例を確認
```ts
const str = "hello";
const value = str as unknown;
```
str の実行時の値は "hello" です。
as unknown によって コンパイラ上の型だけが unknown に変わる。
実行時の value に格納されている値は そのまま "hello"。


### 型アノテーションとsatisfies T型の違い

#### 🔸 具体的にどの部分がわからなかったか
- 定義の違いについて

#### 🔸 解消方法・結果
- ChatGPT
##### 型アノテーション（: T）
```ts
const user: { name: string } = {
  name: "Taro",
  age: 20, // ❌ エラー: 余分なプロパティ
};
```
変数の型を固定する
コンパイラは「代入される値がちょうどその型と一致するか」を厳密にチェック
余計なプロパティはエラーになる
以降も変数の型は T として扱われるので、型推論は失われる

##### 🔹 satisfies T
```ts
const user = {
  name: "Taro",
  age: 20,
} satisfies { name: string };
```
値の型推論を保持したまま、型 T を満たしているかどうかだけを確認する
この場合 user の型は { name: string; age: number } のまま
ただし「少なくとも name: string を持っていること」が保証される
余計なプロパティがあっても OK


### unknownとnever型の意味について

#### 🔸 具体的にどの部分がわからなかったか
- 定義について

#### 🔸 解消方法・結果
- ChatGPT
##### 🔹 unknown
「どんな値が入るかわからない型」
any に似ているが、使うときに型チェックが必要になる点が安全。
```ts
let value: unknown;

value = 1;
value = "hello";
value = { name: "Taro" };

let num: number;
// num = value; // ❌ 型が不明なので代入できない
if (typeof value === "number") {
  num = value; // ✅ 型ガードを通すとOK
}
```
👉 「とりあえず受け取るけど、使うときは型を絞ってね」というときに使う。
例: 外部入力（JSON, APIレスポンスなど）。

##### 🔹 never
「絶対に値が存在しない型」
正常に値を返さない関数の戻り値などに使われる。
```ts
function fail(msg: string): never {
  throw new Error(msg); // 絶対に値を返さない
}
function infiniteLoop(): never {
  while (true) {}
}
```
型的に「到達不可能」を表すこともある。
```ts
type Shape = { kind: "circle" } | { kind: "square" };
function area(shape: Shape) {
  if (shape.kind === "circle") {
    // ...
  } else if (shape.kind === "square") {
    // ...
  } else {
    const _exhaustiveCheck: never = shape; 
    // ✅ 将来、新しい kind が追加されたときにエラーを出す
  }
}
```
👉 「このケースは絶対に存在しない」を保証するための型。


### entriesメソッドの使い方について

#### 🔸 具体的にどの部分がわからなかったか
- 同上

#### 🔸 解消方法・結果
- ChatGPT
##### 🔹 1. 配列に対して entries() を使う
配列の インデックスと値 を [index, value] のペアとして返すイテレーターを作ります。
```ts
const array = ["a", "b", "c"];
for (const [index, value] of array.entries()) {
  console.log(index, value);
}
// 出力:
// 0 "a"
// 1 "b"
// 2 "c"
```
👉 インデックスと値を一緒にループしたいときに便利です。

##### 🔹 2. Object.entries() を使う
オブジェクトに対してはインスタンスメソッドではなく、静的メソッド Object.entries(obj) を使います。
```ts
const obj = { name: "Taro", age: 25 };
for (const [key, value] of Object.entries(obj)) {
  console.log(key, value);
}
// 出力:
// "name" "Taro"
// "age" 25
```
👉 これはオブジェクトの「キーと値」を配列化してループする手段。


### const nev = 1 as never;とした時の振る舞いについて

#### 🔸 具体的にどの部分がわからなかったか
- nevには何が代入されるのか。なぜ1をneverとして代入できてしまうのか

#### 🔸 解消方法・結果
- ChatGPT
##### 🔹 なぜ「never としているのに 1 を代入できる」のか？
本来 never は「絶対に値を持たない型」なので、1 を直接代入することはできません。
```ts
const nev: never = 1; // ❌ エラー
```
しかし、型アサーション（as）を使うと、TypeScript の型チェックを「無理やりすり抜ける」ことができます。
```ts
const nev = 1 as never; // ✅ コンパイルOK
```
👉 これは「1 を never として扱う」と言っているだけで、実際にはただの 1 が入っている。

##### 🔹 実行時の挙動
```ts
const nev = 1 as never;
console.log(nev); // 出力: 1
```
つまり「変数 nev の実行時の中身 = 1」
ただしコンパイラ的には「nev は never 型だから値を使うことはできないはず」と認識されるので、型整合性が壊れます。


### ジェネレーターの定義と利用シーンについて

#### 🔸 具体的にどの部分がわからなかったか
- 同上

#### 🔸 解消方法・結果
- ChatGPT
##### 🔹 ジェネレーターの定義方法

ジェネレーター関数は function* キーワードで定義します。
実行中に yield を使って値を順番に返せます。
```ts
function* counter() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = counter();

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }
```

gen.next() を呼ぶごとに次の yield まで進む
done: false の間は処理が続く
全部終わると done: true

##### 🔹 利用するメリット
1. 遅延処理（必要なときにだけ値を生成）

普通の関数なら一気に配列を返すけど、ジェネレーターなら 必要になったタイミングで値を計算して返せる。
👉 メモリ効率が良く、大きなデータ処理に向いている。
```ts
function* range(n) {
  for (let i = 0; i < n; i++) {
    yield i;
  }
}

for (const num of range(5)) {
  console.log(num); // 0,1,2,3,4
}
```

2. 無限列を扱える
配列では不可能な「無限に続くシーケンス」を表現できる。
```ts
function* naturals() {
  let i = 0;
  while (true) {
    yield i++;
  }
}

const gen = naturals();
console.log(gen.next().value); // 0
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2 ...
```
3. 非同期処理との組み合わせ
（近年は async/await が主流ですが）
昔はジェネレーター + ライブラリ（例: co）で 非同期処理を同期的に書くためによく使われました。


### オプション引数 (?) と ユニオン型 T | undefined のの違いについて

#### 🔸 具体的にどの部分がわからなかったか
- 同上

#### 🔸 解消方法・結果
- ChatGPT
##### 1. オプション引数 (?)
function hello(person?: string) {}
意味: person が渡されてもいいし、省略されてもいい
呼び出し側は 引数を完全に省略可能
```ts
hello();        // ✅ OK （引数なし）
hello("Taro");  // ✅ OK
```
実際の型としては person: string | undefined と推論される
→ つまり「? は | undefined に 呼び出し時の省略可 が加わったもの」

##### 2. ユニオン型 T | undefined
function hello(person: string | undefined) {}
意味: person は必ず引数として渡さなければならない
ただしその値は string または undefined
```ts
hello();        // ❌ エラー: 引数が不足
hello(undefined); // ✅ OK
hello("Taro");  // ✅ OK
```
👉 つまり 引数を「省略」できるか、「明示的に undefined を渡さなければいけないか」 の違い。


### ({ a, b } = { a: 0, b: 0 })と({ a = 0, b = 0 })の違いについて

#### 🔸 具体的にどの部分がわからなかったか
- 振る舞いがどのように変わるのか

#### 🔸 解消方法・結果
- ChatGPT
| 呼び出し方        | ① `({ a, b } = { a: 0, b: 0 })` | ② `({ a = 0, b = 0 })` |
|------------------|-------------------------------|------------------------|
| `foo()`          | ✅ `0 0`                        | ❌ エラーになる         |
| `foo({})`        | `undefined undefined`          | ✅ `0 0`               |
| `foo({ a: 1 })`  | `1 undefined`                  | ✅ `1 0`               |


### Options Object パターンにどのようなメリットがあるか

#### 🔸 具体的にどの部分がわからなかったか
- 同上

#### 🔸 解消方法・結果
- ChatGPT
##### ① 引数の追加・変更がしやすい（後方互換性が高い）
呼び出し元コードを壊さずに引数を追加できる。
引数の順番に依存しないので安全。
```ts
// 新しく "limit" 引数を追加しても元のコードは壊れない
findUsers({
  country: "JP",
  city: "Tokyo",
  order: "id",
  sort: "asc",
  limit: 100
});
```
##### ② 引数の意味が明確になる
名前付きのプロパティで渡すので、コードを見ただけで意味がわかる。
```ts
// 悪い例（位置引数）
findUsers("JP", "Tokyo", "id", "asc");
// 良い例（Options Object）
findUsers({ country: "JP", city: "Tokyo", order: "id", sort: "asc" });
```

##### ③ デフォルト値を設定しやすい
分割代入 + デフォルト値でスマートに初期値を設定できる。
```ts
function findUsers({
  country = "JP",
  city = "Tokyo",
  order = "id",
  sort = "asc",
  limit = 50,
}: {
  country?: string;
  city?: string;
  order?: string;
  sort?: "asc" | "desc";
  limit?: number;
}) {
  // 実装…
}
```
##### ④ 可読性・保守性の向上
引数が多い関数や、変更の多い仕様に対して柔軟に対応できる。
オプションをまとめることで インターフェース化もしやすい。
```ts
type FindUserOptions = {
  country?: string;
  city?: string;
  order?: string;
  sort?: "asc" | "desc";
  limit?: number;
};

function findUsers(options: FindUserOptions) {
  const { country = "JP", city = "Tokyo", order = "id", sort = "asc", limit = 50 } = options;
  // 実装…
}
```


### 型ガード関数とアサーション関数の違い

#### 🔸 具体的にどの部分がわからなかったか
- 同上

#### 🔸 解消方法・結果
- ChatGPT
##### 🔹 1. ユーザー定義の型ガード関数（Type Predicate）
```ts
function isString(value: unknown): value is string {
  return typeof value === "string";
}
```
✅ 特徴：
戻り値の型に value is T の形式（型述語 / Type Predicate）を使う
if文などで使うと、TypeScriptが自動で型を絞り込んでくれる
🔍 使いどころ：
```ts
function handle(value: unknown) {
  if (isString(value)) {
    // ここでは value は string 型として扱える
    console.log(value.toUpperCase());
  }
}
```
##### 🔹 2. アサーション関数（Assertion Function）
```ts
function assertIsString(value: unknown): asserts value is string {
  if (typeof value !== "string") {
    throw new Error("Not a string");
  }
}
```
✅ 特徴：
戻り値の型に asserts value is T の形式を使う
エラーを投げることで、それ以降のコードで value を T 型として扱える
🔍 使いどころ：
```ts
function process(value: unknown) {
  assertIsString(value);  // ここで型を保証（失敗時は例外）
  // ここでは value は string 型とみなされる
  console.log(value.toUpperCase());
}
```



### Promise.allSettled()の定義について

#### 🔸 具体的にどの部分がわからなかったか
- どのタイミングで実行されて、何を返すのか

#### 🔸 解消方法・結果
- ChatGPT
##### 🔹 実行タイミング
```ts
Promise.allSettled([request1(), request2()])
  .then((values) => {
    console.log(values);
  });
```
このコードでは：
request1() と request2() は 同時に実行される
それぞれが resolve または reject されるのを待つ
両方が完了した時点で .then() のコールバックが実行される


### Promiseを明示的に書いた場合のresolveの値について

#### 🔸 具体的にどの部分がわからなかったか
- 具体的に何の値を表しているのか

#### 🔸 解消方法・結果
- ChatGPT
resolve は、Promise を「成功」として完了させるための関数です。
🔹 詳しく説明すると
```ts
new Promise((resolve, reject) => {
  // 非同期処理など
  resolve(値); // 👈「成功した結果の値」を渡す
});
```
この構文で使われる resolve は、Promise コンストラクタのコールバック関数の第1引数として提供されます。
resolve(...) を呼ぶと、その Promise は fulfilled（履行）状態になります。
resolve(...) に渡した値は、.then(...) に渡されます。


### オブジェクトとクラスの違いについて

#### 🔸 具体的にどの部分がわからなかったか
- 定義や使われ方の違い

#### 🔸 解消方法・結果
- ChatGPT
##### 🔹 オブジェクトとクラスの違い

| 観点           | オブジェクト (`{}`)                       | クラス (`class`)                                  |
|----------------|---------------------------|------------------------------|
| 定義方法       | リテラル（直接値を記述）     | クラス構文（`class`）を使う            |
| 使い方         | 単体のデータ構造          | 複数のインスタンスを生成できる設計図     |
| 再利用性       | 基本的に 1 回限り     | インスタンス化で何度も使える           |
| 継承       | できない（ただしプロトタイプ継承は可能）   | `extends` を使って継承できる    |
| 構造       | プロパティとメソッドを持つ   | フィールド、メソッド、コンストラクタなどを持てる |


##### ✅ オブジェクトの例
```ts
const user = {
  name: "Taro",
  greet() {
    console.log(`Hello, ${this.name}`);
  },
};
user.greet(); // Hello, Taro
```
##### ✅ クラスの例
```ts
class User {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  greet() {
    console.log(`Hello, ${this.name}`);
  }
}
const user1 = new User("Taro");
user1.greet(); // Hello, Taro
```


### インターフェースとtypeの違いについて

#### 🔸 具体的にどの部分がわからなかったか
- 定義や使われ方の違い

#### 🔸 解消方法・結果
- ChatGPT
##### ✅ インターフェース（interface）
特徴
特性	説明
主にオブジェクトの構造定義	プロパティやメソッドを持つ「形」を定義
拡張可能	extends を使って継承できる（複数もOK）
宣言マージが可能	同じ名前で複数定義すると自動的に統合される
クラスと親和性が高い	implements でクラスに適用できる
例
```ts
interface Person {
  name: string;
  age: number;
}
interface Employee extends Person {
  company: string;
}
```
##### ✅ 型エイリアス（type）
特徴
特性	説明
あらゆる型に使える	オブジェクト、ユニオン型、プリミティブなど幅広く定義できる
複雑な型定義に強い	条件付き型・ユニオン型・交差型などに向いている
宣言マージはできない	同じ名前で再定義するとエラーになる
interface も含めた再利用が可能	type Foo = Person & { id: number } のような合成が可能
例
```ts
type Point = {
  x: number;
  y: number;
};
type Shape = Point | Circle;
```
## 🔄 `interface` と `type` の違いまとめ表

| 項目               | `interface`             | `type`              |
|--------------------|----------------------|---------------------------|
| **用途**          | オブジェクトの構造     | 幅広い型表現（ユニオン・交差など）       |
| **継承・拡張**     | `extends` で継承できる    | `&`（交差型）で合成可能           |
| **再定義（マージ）** | ✅ 可能（宣言マージができる) | ❌ 不可（同名定義でエラー）         |
| **クラスでの使用** | `implements` で使用可能       | 間接的に使えるが推奨されない       |
| **プリミティブ型** | ❌ 定義不可         | ✅ 定義可能（例: `type ID =string;`  |
| **条件付き型など** | ❌ 不可       | ✅ 高度な型表現が可能（条件付き型、Mapped Types 等） |



### JSXのTタグとTypeScriptのジェネリクスの違いについて

#### 🔸 具体的にどの部分がわからなかったか
- 定義や使われ方の違い

#### 🔸 解消方法・結果
- ChatGPT
##### ✅ 1. 通常の JSX のタグとしての <T>
JSXでは <T> は React コンポーネントや HTML 要素を表すタグです。
例: コンポーネントとしての <T>
```ts
function T() {
  return <div>Hello</div>;
}
export default function App() {
  return <T />; // ✅ これは T コンポーネントの呼び出し
}
```
JSX の <T /> は React コンポーネント T を呼び出していることになります。
T は関数コンポーネント、またはクラスコンポーネントとして定義されている必要があります。

##### ✅ 2. HTMLタグではなく「型」としての T（TypeScriptジェネリクス）
一方、T は ジェネリクスの型引数としても使われますが、それはJSXとは無関係のTypeScriptの構文です。
```ts
function identity<T>(value: T): T {
  return value;
}
```
これは JSX の <T> ではなく、TypeScriptのジェネリクスです。


### MapオブジェクトのRecord型の違について

#### 🔸 具体的にどの部分がわからなかったか
- 定義や使われ方の違い

#### 🔸 解消方法・結果
- ChatGPT
## ✅ 定義の違い：Map オブジェクト vs Record 型

| 観点           | Map オブジェクト              | Record 型                 |
|----------------|------------------------------|--------------------------|
| **言語**       | JavaScript（ランタイム）          | TypeScript（型システム）    |
| **使い方**     | 実行時のデータ構造                | 静的な型定義                 |
| **キーの型**   | あらゆる型（オブジェクトも可）   | 文字列（またはユニオン型）       |
| **メソッド**   | `set`, `get`, `has`, `delete` など| メソッドなし（ただのオブジェクト|
| **反復可能か** | ✅ 可能（`for...of` など)| ❌ 直接は不可（`Object.entries()` が必要）|
| **用途**     | 実行時にキーと値のペアを柔軟に保持| コンパイル時にキーと値を型チェック可能 |



### TSXにおける??と||の違いについて

#### 🔸 具体的にどの部分がわからなかったか
- 定義や使われ方の違い

#### 🔸 解消方法・結果
- ChatGPT
`||` は **falsy な値**（`0`, `''`, `false`, `null`, `undefined`, `NaN`）をすべて無視します。
`??` は **`null` または `undefined` のみ**を無視し、それ以外はそのまま扱います。
| 値            | `value || 'default'` | `value ?? 'default'` |
|---------------|----------------------|-----------------------|
| `null`        | `'default'`          | `'default'`           |
| `undefined`   | `'default'`          | `'default'`           |
| `''` (空文字) | `'default'`          | `''`（空文字）        |
| `0`           | `'default'`          | `0`                   |
| `false`       | `'default'`          | `false`               |


### インポート方法の種類について

#### 🔸 具体的にどの部分がわからなかったか
- どのような種類があるのか、定義や使われ方の違い

#### 🔸 解消方法・結果
- ChatGPT
##### 1. 名前付きインポート（Named Imports）
```ts
import { funcA, VAR_B } from './module';
```
意味: module.ts から funcA と VAR_B という名前のエクスポートをインポートする。
対応するエクスポート:
```ts
export function funcA() {}
export const VAR_B = 42;
```
🔸 使い分け: 複数の関数・定数・型を個別に使いたいとき。名前の自動補完も効く。

##### 2. 名前付きインポート + as（別名）
```ts
import { funcA as myFunc } from './module';
```
意味: funcA を myFunc という名前で使う。
使い道: 名前がかぶる場合や、より意味のある名前にしたい場合。

##### 3. デフォルトインポート（Default Import）
```ts
import MyClass from './module';
```
対応するエクスポート:
```ts
export default class MyClass {}
```
🔸 使い分け: モジュールが 1 つの主な機能（例：1つのクラスや関数）を持つ場合。

##### 4. 名前付き + デフォルト同時インポート
```ts
import MyClass, { helperFunc } from './module';
```
意味: デフォルトエクスポートと名前付きエクスポートを同時にインポート。

##### 5. 名前空間インポート（全部まとめて）
```ts
import * as Utils from './module';
```
意味: module.ts のエクスポートをすべて Utils という名前空間にまとめて使う。
```ts
Utils.funcA();
Utils.VAR_B;
```
🔸 使い分け: モジュールの中身をひとまとまりで扱いたい場合や、インポート名が多すぎるとき。

##### 6. タイプのみインポート（TypeScript専用）
```ts
import type { User } from './types';
```
意味: 型情報だけをインポートする（コンパイル後に削除される）。
対応するエクスポート:
```ts
export type User = { name: string };
```
🔸 使い分け:
実行時に不要な型だけをインポートしたいとき
import cycle（循環参照）を防ぐときに有効

##### 7. Dynamic Import（動的インポート）
```ts
const module = await import('./module');
module.funcA();
```
特徴: 実行時にモジュールを読み込む。Promise を返す。
使い分け: 条件によって読み込むモジュールを変えたいとき、初期表示を高速化したいとき（遅延読み込み）。


### エクスポート方法の種類について

#### 🔸 具体的にどの部分がわからなかったか
- どのような種類があるのか、定義や使われ方の違い

#### 🔸 解消方法・結果
- ChatGPT
##### ✅ ESモジュール（ESM）のエクスポート方法
ESModules は import / export を使用する 静的モジュールシステム です。

###### 1. 名前付きエクスポート（Named Export）
```ts
// utils.ts
export const name = "Alice";
export function greet() {}
export type User = { name: string };
```
使い方（インポート側）：
```ts
import { name, greet, User } from "./utils";
```
###### 2. デフォルトエクスポート（Default Export）
```ts
// config.ts
const config = { debug: true };
export default config;
```
使い方：
```ts
import config from "./config";
```
###### 3. 名前付きとデフォルトの同時エクスポート
```ts
// index.ts
export const VERSION = "1.0";
const main = () => {};
export default main;
```
使い方：
```ts
import main, { VERSION } from "./index";
```
###### 4. 複数まとめてエクスポート
```ts
// api.ts
const get = () => {};
const post = () => {};
export { get, post };
```
###### 5. 別名をつけてエクスポート（as）
```ts
export { get as fetchGet, post as fetchPost };
```
###### 6. 再エクスポート（リレースルー）
```ts
export * from "./user";
export { login } from "./auth";
```
##### ✅ CommonJS（CJS）のエクスポート方法
CommonJS は主に Node.js で使われる 動的モジュールシステム です。

###### 1. module.exports で全体をエクスポート
```ts
// utils.js
function greet() {}
module.exports = { greet };
```
使い方：

```ts
const utils = require("./utils");
utils.greet();
```
###### 2. exports オブジェクトを使う
```ts
// math.js
exports.add = (a, b) => a + b;
exports.sub = (a, b) => a - b;
```
###### 3. デフォルトエクスポート的に使う
```ts
// config.js
module.exports = { apiKey: "123" };
const config = require("./config");
```


### 変性の概念について

#### 🔸 具体的にどの部分がわからなかったか
- 共変性、反変性、不変性、双変性の定義と違いについて

#### 🔸 解消方法・結果
- ChatGPT
##### 変性（variance）のざっくり整理
- 共変 (covariant): サブタイプをそのまま使える
戻り値の型には共変が許される
- 反変 (contravariant): サブタイプの逆を受け入れられる
引数の型は反変でなければならない
- 不変 (invariant): 完全一致しか許されない
###### 🔍 意図としてはこういうことを「概念的に」言っています
型名	概念的意味（変性）	説明
- BivariantFunction<I, O>	双変性（引数・戻り値両方がバリアント）	両方向に代入可能（実際には危険）
- CovariantFunction<I, out O>	戻り値のみが共変	戻り値がサブ型なら代入できる
- ContravariantFunction<in I, O>	引数のみが反変	引数がスーパータイプなら代入できる
- InvariantFunction<in out I, in out O>	不変	I, O の両方が完全一致しないと代入不可
##### ✅ TypeScriptで「それらを再現」する実装例

TypeScriptでは in / out の代わりに、型の使われ方によって変性が決まります。以下のように書き換えて理解しましょう：
```ts
// 🔁 双変性（引数・戻り値の両方を比較対象に）
type BivariantFunction<I, O> = (arg: I) => O;
// ✅ 共変性（戻り値のみ比較）
type CovariantFunction<O> = () => O;
// ✅ 反変性（引数のみ比較）
type ContravariantFunction<I> = (arg: I) => void;
// 🔒 不変性（完全一致のみ）
type InvariantFunction<I, O> = (arg: I) => O;
```
##### 変性による代入例
```ts
class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}

declare const bivariant: (arg: Dog) => Dog;
declare const covariant: () => Dog;
declare const contravariant: (arg: Dog) => void;
declare const invariant: (arg: Dog) => Dog;

// 変性チェック
const bi1: (arg: Animal) => Dog = bivariant; // ✅ OK（バリアントなので通る）
const co1: () => Animal = covariant;         // ✅ OK（Dog は Animal のサブ型）
const contra1: (arg: Dog) => void = contravariant; // ✅ OK
const inv1: (arg: Animal) => Dog = invariant;      // ❌ 型不一致（不変性）
```
🧠 補足まとめ
概念名	実際のTypeScript実装の例	ポイント
共変性	type Cov<T> = () => T	戻り値に現れる型はサブタイプでOK
反変性	type Contra<T> = (arg: T) => void	引数に現れる型はスーパータイプでOK
不変性	type Invar<T> = (arg: T) => T	完全一致のみOK
双変性（危険）	(arg: T) => T（一部チェック甘い）	TypeScriptが緩く通すケースがあるため注意


### tsにおけるパッケージとライブラリの違いついて

#### 🔸 具体的にどの部分がわからなかったか
- 定義の違い

#### 🔸 解消方法・結果
- ChatGPT
##### ✅ 共通点（≒といえる理由）
どちらも「再利用可能なコードのまとまり」を指す
npm で配布されるものを「ライブラリ」と呼ぶ人もいれば「パッケージ」と呼ぶ人もいる
例: lodash を「ユーティリティライブラリ」と呼ぶ人もいれば「npm パッケージ」と言う人もいる
##### ⚖️ 違い（厳密にいうと）

###### パッケージ
技術的な用語
package.json を持っている → npm/yarn/pnpm で配布・管理できる単位

###### ライブラリ
概念的・一般的な呼び方
npm に公開されてなくても、社内の共通関数集やクラス群を「ライブラリ」と呼べる
💡 例
react → 「UIライブラリ」と呼ばれる（概念的な分類）
でも配布形態としては npm の「パッケージ」


### tsにおけるパッケージとライブラリの違いついて

#### 🔸 具体的にどの部分がわからなかったか
- 定義の違い

#### 🔸 解消方法・結果
- ChatGPT
##### 1. call
使い方:
```ts
func.call(thisArg, arg1, arg2, ...);
```
意味:
関数 func を 即座に実行する
this を thisArg に設定できる
引数は カンマ区切り で渡す
例
```ts
function greet(greeting) {
  console.log(`${greeting}, ${this.name}`);
}
const person = { name: "Alice" };
greet.call(person, "Hello"); 
// Hello, Alice
```
##### 2. apply
使い方:
```ts
func.apply(thisArg, [arg1, arg2, ...]);
```
意味:
call とほぼ同じ
違いは「引数を配列（または配列風オブジェクト）で渡す」
例
```ts
greet.apply(person, ["Hi"]); 
// Hi, Alice
```
👉 配列で引数をまとめて渡せるので、例えば Math.max と組み合わせると便利：
```ts
const nums = [5, 10, 3];
console.log(Math.max.apply(null, nums)); // 10
```
##### 3. bind
使い方:
```ts
const newFunc = func.bind(thisArg, arg1, arg2, ...);
```
意味:
新しい関数を返す（即実行しない）
その新しい関数を呼ぶときに this が固定される
部分適用（カリー化みたいなこと）もできる

例
```ts
const greetAlice = greet.bind(person, "Hey");
greetAlice(); 
// Hey, Alice
```


### npm createとnpx createの違いについて

#### 🔸 具体的にどの部分がわからなかったか
- 働きの違いや使い分け

#### 🔸 解消方法・結果
- ChatGPT
どちらも プロジェクトの雛形を作るコマンド
グローバルにツールをインストールしてなくても使える
実際には npm レジストリからパッケージを一時的にダウンロードして実行している

##### (1) フレームワークの違い
`npm create vite@latest`
Vite プロジェクトを作成
軽量で高速なビルドツール、フレームワークに依存しない
テンプレート指定で react, vue, svelte, preact など選べる
`npx create-next-app`
Next.js 専用プロジェクトを作成
React ベースのフルスタックフレームワーク
ルーティング、SSR、API Routes などフル機能付き

##### (2) コマンドの仕組み
`npm create vite@latest`
npm create は npm init のシンタックスシュガー
実際には create-vite@latest というパッケージを取得して実行している
`npx create-next-app`
npx は「パッケージを一時的にダウンロードして実行する」仕組み
create-next-app パッケージを取得して実行
👉 つまり「呼び出し方が違うだけ」で、どちらも create-xxx パッケージを叩いているのは共通。

##### (3) オプションの扱い
Vite:
`npm create vite@latest my-app -- --template react-swc-ts`
→ --template でテンプレートを選ぶ
Next.js:
`npx create-next-app random-cat`
→ 対話形式で TypeScript/ESLint/Tailwind などを選べる（フラグで指定も可能）



### npxプロジェクトを立ち上げる際の確認内容について

#### 🔸 具体的にどの部分がわからなかったか
- 働きの違いや使い分け

#### 🔸 解消方法・結果
- ChatGPT

##### 1. Would you like to use App Router? (recommended)
👉 App Router を使うかどうかの確認です。
- Yes
app/ ディレクトリを使った App Router ベースの新しいルーティングシステムが有効になる
ページは app/page.tsx のように作る
サーバーコンポーネント（React Server Components）やレイアウト、ストリーミングなど最新機能が利用可能
- No
旧来の Pages Router を使う
ページは pages/index.tsx のように作る
従来からのプロジェクトや一部ライブラリ互換のために残っている方式
💡 新規開発なら基本的に App Router (Yes) が推奨です。

##### 2. Would you like to use Turbopack for next dev?
👉 開発サーバー (next dev) のバンドラとして Turbopack を使うかどうか。
- Yes
Rust 製の次世代ビルドツール「Turbopack」を使う
Vite や esbuild よりもさらに高速を目指している
まだ実験的なので、一部ライブラリや設定で不具合がある可能性もある
- No
既存の Webpack ベースの開発サーバーを使う
安定性重視
💡 新しい機能を試したいなら Yes、安定性重視なら No。

##### 3. Would you like to customize the import alias (@/* by default)?
👉 インポートパスのエイリアス設定をカスタマイズするかどうか。
- Yes
例えば @/components/Button のように使うデフォルトを変更できる
自分のチームの流儀に合わせて ~/* や src/* などにできる
- No
デフォルトのまま（@/* → src/ 直下を指す）
💡 エイリアスを設定しておくと、長い相対パス（例: ../../../components/Button）を書かずに済みます。


### next.jsのset serverについて

#### 🔸 具体的にどの部分がわからなかったか
- 働きや利用目的について

#### 🔸 解消方法・結果
- ChatGPT
##### 🔹 1. ローカル開発環境の場合
npm run dev で立ち上がる開発サーバー（Node.js プロセス）の中で "use server" の関数が実行されます。
つまり「自分の Mac の Node.js 上」がサーバー。

##### 🔹 2. 本番デプロイの場合
Next.js のアプリは どこにデプロイするかでサーバーの実体が変わります。
(a) Vercel にデプロイした場合
"use server" の関数は **Vercel のサーバーレス環境（Edge Functions や Serverless Functions）**で動きます。
リクエストが来るたびにサーバー側でその処理が実行されます。
(b) 自前で Node.js サーバーを建てる場合
例えば AWS EC2, GCP, Heroku などに Next.js をデプロイすると、そのサーバーの Node.js 環境で "use server" 関数が実行されます。
(c) Docker コンテナに入れて動かす場合
コンテナの中の Node.js プロセスが「サーバー」として動く。

##### 🔹 3. 「サーバー」の正体
要するに、Next.js の "use server" が指している「サーバー」とは：
ブラウザ（クライアント）側ではなく、Node.js が動いている環境
デプロイ先によって、
ローカルの開発サーバー
Vercel のサーバーレス基盤
AWS/GCP/Azure の VM やコンテナ
などがサーバーの実体になる


### SSRのためのサーバーとuse serverが指すサーバーの違いについて

#### 🔸 具体的にどの部分がわからなかったか
- 同上

#### 🔸 解消方法・結果
- ChatGPT
##### 🔹 "use server" の「サーバー」
これは 「関数をサーバーで実行させる」ための指定です。
SSR そのものを指すのではなく、ユーザーの操作に応じた処理（DB操作、フォーム送信処理など）をブラウザではなくサーバーで行うための仕組み。
例：
```tsx
"use server";

export async function saveData(formData: FormData) {
  // これはブラウザには送られない
  // サーバー環境(Node.js)でだけ実行される
  await db.user.create({ name: formData.get("name") });
}
```
👉 "use server" は 「どこでその関数を実行するか」 を明示しているだけで、SSR か CSR かというレンダリング方式の話とは直接関係しません。

##### 🔹 整理すると
SSR のサーバー
初回リクエストに応じて HTML をサーバーで生成する場所
ページ全体をどう返すかのレイヤー
"use server" のサーバー
アプリの中の関数を ブラウザではなく Node.js 側で実行する場所
個別のアクションやビジネスロジックを担うレイヤー
👉 つまり 同じ Node.js 実行環境を指してはいるけれど、
SSR は「ページレンダリング」
"use server" は「関数実行」
にフォーカスしている、という違いです。




### next.jsのServer Actionsについて

#### 🔸 具体的にどの部分がわからなかったか
- 働きや利用目的について

#### 🔸 解消方法・結果
- ChatGPT
##### 🔹 1. 前提
SSR (Server-Side Rendering)
→ ページリクエストに応じてサーバーで HTML を生成して返す仕組み。
Server Actions ("use server")
→ 特定の関数を「必ずサーバー上で実行」させる仕組み。
（クライアントに配布されず、RPC のように呼び出される）
どちらも「サーバー」と言っていますが、フォーカスが違うんです。

##### 🔹 2. 「クライアント側で "use server" を指定する」は可能か？
はい、可能です。
クライアントコンポーネントのコードから サーバーアクションを呼び出すことはできます。
例：
```ts
// actions.ts
"use server";

export async function saveData(formData: FormData) {
  await db.user.create({ name: formData.get("name") });
}

// ClientComponent.tsx
"use client";
import { saveData } from "./actions";

export default function ClientComponent() {
  return (
    <form action={saveData}>
      <input name="name" />
      <button type="submit">Save</button>
    </form>
  );
}
```
👉 ここで ClientComponent はブラウザで動きますが、saveData は "use server" と書かれているので サーバー（Node.js 実行環境）で実行されるんです。

##### 🔹 3. その「サーバー」とはどこ？
この「サーバー」は SSR を実行しているのと同じサーバー環境です。
ローカル開発なら → npm run dev で動いている Node.js
Vercel なら → Vercel の Serverless/Edge Functions
自前デプロイなら → EC2 / ECS / Lambda などの Node.js
つまり：
SSR → ページ全体をサーバーでレンダリング
Server Actions ("use server") → クライアントからの呼び出しをサーバー側で処理
👉 実体は同じサーバーだけど、役割が違う。


---

## 💡 その他気づいたこと
- オブジェクト、配列を不変にするにはreadonlyプロパティが必要(チェックを受けるのはコンパイル時のみで、コンパイル後は代入可能になる)
- インデックス型はオブジェクト型の一種
- verselにnext.jsのアプリをpushする前に、アプリをgithubにプッシュしておく必要がある


---

## 🛠️ コンテンツの改善点
- 情報のインプット量が多い、似たような概念が多い、説明が教科書的でわかりづらいなどが原因で、初めてTypeScriptを学ぶという前提ではインプットが難しいため、説明をもう少しわかりやすくするために、他の人がつまづいた部分をまとめておくか、インプットする情報の優先度付けを行って、飽和しないようにする必要があると感じる。



