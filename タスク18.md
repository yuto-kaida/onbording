# 📌 タイトル
- React 公式ガイド

---

## 💼 業務で活かす場面
- フロントエンドアプリケーション(SPA)の構築

---

## 🎯 学習目的
- Reactの基本的な仕組みと、その技術がどのような意図を持って生み出されたものなのかを理解することにより、実際の開発において、どのように実装すべきかを根拠を持って決定できるような状態を目指す

---

## 📝 全体の感想
- 基本的な概念だけでなく、その技術や仕組みがなぜ存在するのか、どのような実装を行うことが理想的なのかまで説明されているため、まだコードをあまり書いたことがない状態で理解することは難しい部分もあるが、Reactの本質的なコードの書き方が理解できて非常に学びになった。
- React を理解する上で、レンダリングと副作用の概念をしっかりと理解しておくことが重要であることを感じた。

## 📖 内容の要約

### 全体構成
- UI の記述
- インタラクティビティの追加
- state の管理
- 避難ハッチ

#### UI の記述
- コンポーネントが他のコンポーネントをレンダーすることはできるが、定義をネストさせることはできない。
- 以下のようにコンポーネントをネストした場合、親コンポーネントはその中身を children という props として受け取る
```jsx
<Card>
  <Avatar />
</Card>
```
- react では、制御フローは JavaScript で処理される
- コンポーネント(レンダー関数)は通常、純粋性を保つべきであるが、イベントハンドラはそうである必要はない。

#### インタラクティビティの追加
- イベントハンドラは通常、handle の後ろにイベント名称をつなげた名前にすることが一般的
- useState フックは、レンダー間でデータを保持する state 関数と、再レンダーをトリガーする state セッタ関数をを持っている
- 再レンダーは、更新関数を実行した後ではなく、イベントハンドラの実行が終わった後に起きる

#### state の管理
- UI の状態を可視化する際の種類として、以下のようなものがある
  -- Empty：フォームには無効な “Submit” ボタンがある。
  -- Typing：フォームには有効な “Submit” ボタンがある。
  -- Submitting：フォームは完全に無効化される。スピナが表示される。
  -- Success：フォームの代わりにお礼のメッセージが表示される。
  -- Error：Typing 状態と同様だがエラーメッセージも表示される。
- 上記の状態を保持するための state を用意し、必要でない部分は削除する
- 関連する state はグループ化する：2 つの state 変数が常に一緒に更新される場合は、単一の state 変数にまとめるのが良い
- 同じ位置の異なるコンポーネントは state をリセットする
```jsx
{
  isFancy ? (
    <div>
      <Counter isFancy={true} />
    </div>
  ) : (
    <section>
      <Counter isFancy={false} />
    </section>
  );
}
```
- 異なる位置でコンポーネントをレンダーしても state はリセットされる
```jsx
{
  isPlayerA && <Counter person="Taylor" />;
}
{
  !isPlayerA && <Counter person="Sarah" />;
}
```
- 異なる key を指定すると、state が保持されなくなる
```jsx
{
  isPlayerA ? (
    <Counter key="Taylor" person="Taylor" />
  ) : (
    <Counter key="Sarah" person="Sarah" />
  );
}
```

#### 避難ハッチ
- ref で管理している値を直接レンダーしようとすると問題になるが、レンダーする情報に必要な情報として用いる場合は問題ない
- React が ref.current をセットするのはコミット中
- ref は避難ハッチであり、React の外に踏み出す必要がある場合に使用する
- エフェクトが必要になるタイミングは、通常、ブラウザ API、サードパーティのウィジェット、ネットワークなど、React のコードから踏み出して外部システムと同期するためのもの
- エフェクトは、全てのコミット後に実行される
- エフェクトの依存配列には、全てのリアクティブな値が含まれている必要があり、依存配列を選ぶことはできない
- ユーザー操作に起因した処理はイベントハンドラ、ユーザーが行った特定の操作に依存しない処理はエフェクトを使用する
- イベントハンドラはリアクティブではないが、エフェクトはリアクティブ
- カスタムフックは、state自体ではなく、stateを扱うロジックを共有できるようにするためのもの

---

## ❓ 不明点・疑問点

### React におけるレンダーフェーズとコミットフェーズの違い

#### 🔸 具体的にどの部分がわからなかったか
- 具体的にどこからどこまでが該当するのか

#### 🔸 解消方法・結果
- ChatGPT

##### レンダーフェーズ (render phase)

新しい UI（仮想 DOM / React elements）を「計算する」段階
コンポーネント関数が呼ばれるのはこのタイミング
render()（関数コンポーネントなら return の JSX）を評価する
副作用（useEffect 内の処理など）は実行されない
純粋に「次はこういう UI になるよ」というスナップショットを準備する作業

##### コミットフェーズ (commit phase)

レンダーフェーズで計算した差分を、実際の DOM に反映する段階
ここでブラウザの DOM が更新される
useLayoutEffect / useEffect の副作用が実行されるのもこのタイミング

##### ✅ タイミングをコードでイメージ

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  console.log("レンダー中");

  useEffect(() => {
    console.log("コミット後に呼ばれる副作用");
  });

  return <h1>{count}</h1>;
}
```

setCount(1) を呼ぶ
レンダーフェーズ
Counter() が再実行される
console.log("レンダー中") が走る
React は新しい Virtual DOM ```HTML(<h1>1</h1>)``` を用意する
コミットフェーズ
React が実際の DOM ```HTML(<h1>0</h1>)``` を ```HTML<h1>1</h1>``` に差し替える
DOM 更新後に useEffect のコールバックが呼ばれる

### useEffect のクリーンアップ関数がよばれるタイミング

#### 🔸 具体的にどの部分がわからなかったか

- 具体的なタイミング

#### 🔸 解消方法・結果

- ChatGPT

##### ✅ 1. コンポーネントがアンマウントされたとき

「アンマウント」とは、コンポーネントが UI から削除されることです。
例

```jsx
function Chat() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();

    return () => {
      connection.disconnect(); // 👈 アンマウント時に呼ばれる
    };
  }, []);

  return <h1>Chat room</h1>;
}

function App() {
  const [show, setShow] = useState(true);
  return (
    <>
      <button onClick={() => setShow(!show)}>Toggle</button>
      {show && <Chat />}
    </>
  );
}
```

ボタンを押して show が false になると <Chat /> が UI から消える（アンマウント）
その瞬間、useEffect の クリーンアップ関数（disconnect） が呼ばれる
👉 WebSocket の切断、イベントリスナーの解除、タイマーの停止などをここで行う

##### ✅ 2. 依存が変わるとき

「依存」とは useEffect の第 2 引数の配列（依存配列）です。

```jsx
useEffect(() => {
  // effect 本体
  return () => {
    // クリーンアップ
  };
}, [依存する値]);
```

この配列に入っている値が変わると：
React は古いエフェクトをクリーンアップする（返された関数を呼ぶ）
そのあと、新しい値を使ってエフェクトを再実行する
例：チャットルームの切り替え

```jsx
function Chat({ roomId }) {
  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();

    return () => {
      connection.disconnect(); // 👈 roomId が変わるとき呼ばれる
    };
  }, [roomId]); // 👈 依存配列に roomId
}
```

roomId="general" のときに接続開始
roomId が "travel" に変わった瞬間：
古い接続を disconnect（クリーンアップ）
新しい roomId を使って再接続
👉 「依存が変わる」とは、依存配列に含めた値が更新されたことを意味します。

### useEffect と useSyncExternalStore の使い分け

#### 🔸 具体的にどの部分がわからなかったか

- どちらを選ぶべきかの判断基準

#### 🔸 解消方法・結果

- ChatGPT

##### 1. 「外部の状態を購読したい」のか？

例：Redux、Zustand、外部の WebSocket クライアント、navigator.onLine など
React の外で「値が変わる可能性があるもの」を常に最新に保ちたい
→ useSyncExternalStore を使う
理由：
useEffect で購読すると 並列レンダリング中に「古いスナップショットを読む」問題が起きる可能性がある。
useSyncExternalStore は React 18 以降で公式に保証された「外部ストア購読の安全な方法」。

##### 2. 「副作用（外部に影響を与える処理）」をしたいのか？

例：API リクエスト、ログ送信、DOM の操作、setInterval、イベントリスナー登録
React の描画とは関係なく「外の世界に対して何かする」
→ useEffect を使う
理由：
useEffect は「レンダー結果を DOM に反映したあと」に呼ばれるので、副作用を安全に発火できる。
（= React のレンダー → コミットが終わった後に処理する仕組み）

##### 3. 「React 内の state で完結するか？」

その値が React コンポーネント内の useState で十分表現できる
外部ストアや外部環境を購読する必要がない
→ useEffect も useSyncExternalStore も不要

### 通常の関数ではなく useEffectEvent を利用する理由

#### 🔸 具体的にどの部分がわからなかったか

- 同上

#### 🔸 解消方法・結果

- ChatGPT

##### ✅ まず前提：なぜ必要なのか？

useEffect の中で関数（イベントハンドラ的な処理）を参照したいとき、依存関係の管理が面倒になるのが課題でした。
例：

```ts
useEffect(() => {
  function sendLog() {
    console.log("Current user:", userId);
  }

  window.addEventListener("click", sendLog);
  return () => window.removeEventListener("click", sendLog);
}, [userId]); // ← userId が変わるたびにリスナーを付け直す必要がある
```

userId を依存配列に入れると、毎回リスナーを貼り直すことになり無駄
でも依存配列から外すと、古い userId をキャプチャしたままになり「stale closure（古い値の捕捉）」が起きる
👉 この「最新の state/props を参照しつつ、依存関係で無駄な再登録を避けたい」問題を解決するために登場したのが useEffectEvent です。

##### ✅ useEffectEvent の使い方

```ts
import { useEffect, useEffectEvent } from "react";

function MyComponent({ userId }) {
  const onClick = useEffectEvent(() => {
    // ✅ 常に最新の userId を参照できる
    console.log("Current user:", userId);
  });

  useEffect(() => {
    window.addEventListener("click", onClick);
    return () => window.removeEventListener("click", onClick);
  }, []); // ✅ 依存配列は空でOK！
}
```

useEffectEvent で定義した関数は 常に最新の props/state にアクセス可能
かつ「イベントリスナーとしての関数の参照自体」は安定している（毎回作り直さなくてよい）
これにより「無駄なクリーンアップ」「古い値の捕捉」の両方を回避できる

##### ✅ じゃあ「普通の関数」じゃダメなの？

普通の関数を useEffect 内で使うと：
関数はレンダーごとに新しく生成される
依存配列に入れると無駄に副作用が走る
入れないと古い state/props を使ってしまう（stale closure 問題）
useEffectEvent を使うと：
React が内部的に「イベント関数は最新のスナップショットを見る」よう保証してくれる
依存配列に入れる必要がなくなる
コードがシンプルで安全になる



### カスタムフックはどこで定義すべきか

#### 🔸 具体的にどの部分がわからなかったか
- 具体的にどこからどこまでが該当するのか

#### 🔸 解消方法・結果
- ChatGPT
##### ✅ 基本的な考え方
UI に依存しない「ロジック」だけを持つカスタムフック
→ 共通的に使えるように hooks/ ディレクトリなどにまとめる
特定の機能やモジュールに強く依存するカスタムフック
→ その機能（feature）やコンポーネントと同じ階層に置く

##### ✅ よくあるレイヤー分けの例
###### 1. src/hooks/
プロジェクト全体で使える汎用的なフックを置く場所
例：
useWindowSize
useLocalStorage
useOnlineStatus
src/
  hooks/
    useWindowSize.js
    useLocalStorage.js
    useOnlineStatus.js

###### 2. src/features/<feature>/hooks/
特定の機能に関係するフックをまとめる
例：チャット機能のための useChatRoom
src/
  features/
    chat/
      hooks/
        useChatRoom.js
      components/
        ChatWindow.js
👉 その機能に閉じたロジックなら、グローバルに公開せず「近いところに置く」方が分かりやすい。

###### 3. コンポーネントファイルの横に置く
そのコンポーネント専用のフックで、再利用性はあまりない場合
例：useAutoScroll（特定のチャット画面専用など）
src/
  features/
    chat/
      components/
        ChatWindow/
          ChatWindow.js
          useAutoScroll.js



### React における「内部」と「外部」

#### 🔸 具体的にどの部分がわからなかったか
- 具体的にどこからどこまでが該当するのか

#### 🔸 解消方法・結果
- ChatGPT
###### 内部 (React world)
- JSX
- state
- props
- コンポーネントの再レンダーの流れ

###### 外部 (External system)
- DOM（実ブラウザ API）
- ネットワーク接続（WebSocket, API）
- タイマー (setInterval)
- アニメーションエンジン
- 外部ライブラリや SDK
👉 React コンポーネントの「責務」は UI を宣言的に表現すること。
外部の副作用的なロジックは「外部システム」に任せたほうが、UI がシンプルで分かりやすくなる。

##### ✅ 引用文の例で考える
「複数のアニメーションを連動させる」
もしこれを useEffect に直接書くと：
複数のエフェクト間で状態を調整する必要がある
UI ロジックとアニメーション制御がごちゃ混ぜになる

##### ✅ ロジックを抽出するとどうなるか
例えばアニメーション制御をクラスや関数にまとめる：
```jsx
class AnimationController {
  constructor(element) {
    this.element = element;
  }
  start() { /* 複雑なアニメーション開始 */ }
  stop() { /* 停止 */ }
}
```
React 側ではこれを 外部システムとして接続するだけ：
```jsx
useEffect(() => {
  const controller = new AnimationController(ref.current);
  controller.start();
  return () => controller.stop();
}, []);
```
👉 このとき、AnimationController は React から見れば外部ライブラリ と同じ扱いになる。

##### ✅ 「外部システムになる」とは？
つまり：
抽出したロジックは React のレンダーサイクルから切り離される
React から見ると「WebSocket とか DOM API と同じように、外部の仕組み」
React はそれに「接続する／切断する」責務だけを持ち、内部の詳細を気にしなくてよくなる

##### ✅ まとめ
「外部システムになる」とは
➡ 抽出したロジックが React コンポーネントの外に独立した仕組みとして存在し、React からは単に“接続対象”として扱える という意味。
👉 言い換えると、「React コンポーネントから見たときに、それが 自作のミニライブラリや SDK のように振る舞う」ということです。



---

## 💡 その他気づいたこと
- React(特にエフェクト周り)を理解する上で、副作用という概念について理解しておくことが重要である。
(参考) [Reactの文脈での「副作用」について](https://zenn.dev/uhyo/articles/react-two-side-effects)

---

## 🛠️ コンテンツの改善点
- 最後のエフェクト周りの部分の分量が多いうえ、本質的な部分にまで触れた内容になっているため、初学者がどこまでついていけるのかというのは少し悩ましい部分ではあると感じる。とはいえ、Reactメインで開発を行っていく上では非常に重要な内容であるとも感じるため、ある程度開発経験を積んでから学ぶコンテンツ(中級向け)として移行するかどうかは、検討の余地があると感じる
- このコンテンツに限った話ではないが、各コンテンツや、そのコンテンツに含まれる各テーマの難易度、および、業務における理解の重要度がどの程度のものなのかを一度吟味し、レビューをつけておくだけでも、学習の進め方の参考になると感じた。

