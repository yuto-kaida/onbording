# 📌 タイトル
- A tour of Go（Goのチュートリアル）

---

## 💼 業務で活かす場面
- バックエンドアプリケーションの開発

---

## 🎯 学習目的
- アプリケーションの開発時に、基本的な知識についてはスムーズに引き出すことができるように、事前にインプットしておく
- 自分でコーディングしてアウトプットすることで、実際のプログラミングのイメージを掴むと同時に、インプットした知識を定着させる

---

## 📝 全体の感想
- 全体的に教科書的な説明が少なく、出てくる概念(クロージャ、レシーバなど)を都度自分で調べて補っていく必要がある
- 練習問題は、本格的なロジックを組む必要がある問題が多く、プログラミング経験のない方がいきなり取り組むには、かなりハードルが高いように感じる

---

## 📖 内容の要約

### 全体構成
- 基本概念(パッケージ、変数、関数)
- 制御構文(if, else, for, switch, defer)
- 応用的な型(ポインタ、構造体、配列、スライス、マップ)
- 型と継承(メソッド、インターフェース)
- 並列処理(ゴルーチン、チャネル, Mutex)

#### パッケージ
- Goのプログラムはパッケージで構成される
- プログラムはmainパッケージで開始され、その他で必要なパッケージは都度インポートする

#### 変数
- Goの変数では、bool、String、int、uint、uintptr、float、complexの型が存在

#### 関数
- 基本定義は、`func 関数名(入力変数1 入力変数1の方) (出力変数1の型, 出力変数2の型){}`
- 出力変数部分に変数名を記載すると、return文に変数名を記載しなくて良い

#### 制御構文
- for文でwhile相当を記載可能
- switch文では、選択されたcaseだけを実行し、そこでbreakされる
- `defer 処理`と記載すると、その呼び出し元の関数がreturnするまでその処理は実行されない

#### 応用的な型
- ポインタとは、変数のメモリアドレスを指す変数の型
- 配列は固定長で、スライスは可変長
- 構造体とマップの違いはキーが存在するかどうか
- クロージャは、変数に紐づけて、紐づけた変数値を動的に変更することができる

#### 型と継承(メソッド、インターフェース)
- クラスの仕組みはないが、レシーバを持つ関数を作成すると、それがメソッドになる
- ポインタレシーバを付与すると、その構造体のフィールドを書き換えることができる
- インターフェースはメソッドの集合を定義

#### 並列処理(ゴルーチン、チャネル, Mutex)
- ゴルーチンは、Goのランタイム管理下で並列に処理を走らせる
- チャネルを通じて値の送受信ができる
- Mutexを利用することで排他制御の実現が可能


---

## ❓ 不明点・疑問点

### 関数とメソッド、クロージャの違い

#### 🔸 具体的にどの部分がわからなかったか
- それぞれが持つ意味の違いと使い分け

#### 🔸 解消手段・解消結果
- ChatGPT
# Goにおける 関数・メソッド・クロージャ の違い

| 項目       | 関数 (Function)      | メソッド (Method)          | クロージャ (Closure)                  |
|------------|------------------------|-------------------------------|--------------------------------|
| 紐づく対象 | なし                        | 型（構造体や定義済み型）            | 外側のスコープの変数            |
| 定義方法   | `func 名(...) {...}`  | `func (receiver 型) 名(...) {...}`  | `変数 := func(...) {...}`       |
| 主な用途   | 独立した処理の定義          | 型の振る舞いを表す    | 状態を持つ関数／コールバック／関数型の返却    |
| 例         | `add(2, 3)`              | `user.Greet()`        | `increment()` （呼ぶたびに状態が変化する）    |


### メソッドとインターフェースの違い

#### 🔸 具体的にどの部分がわからなかったか
- それぞれが持つ意味の違いと使い分け

#### 🔸 解消手段・解消結果
- ChatGPT
##### <メソッド>
##### 役割
- 特定の型に「振る舞い」を持たせる。
##### 使いどころ
- 構造体や型に直接関連する処理  
- その型の状態（フィールド）を参照・更新する処理  

---

##### <インターフェース>
##### 役割
- 「この型はこれらのメソッドを持っていれば使える」という **契約** を定義する。
##### 使いどころ
- 関数の引数・戻り値を「抽象化」したいとき  
- 具体的な型に依存せず、共通の振る舞いに基づいて処理したいとき  
- 例：ファイルもソケットも「Readできる」なら同じ関数に渡せる  


### ゴルーチンの実行の仕組みについて

#### 🔸 具体的にどの部分がわからなかったか
- ゴルーチンで実行される処理は、どの処理と並列で実行されるのか
- ゴルーチンを呼び出す大元はどこか

#### 🔸 解消手段・解消結果
- ChatGPT

##### 階層イメージ
- Goプログラム  
  └─ Goランタイム  
&emsp; ├─ **OSスレッド1** → ゴルーチンA, ゴルーチンB  
&emsp; ├─ **OSスレッド2** → ゴルーチンC  
&emsp; └─ **OSスレッド3** → ゴルーチンD, ゴルーチンE  

##### ポイント
- Go のプログラム実行時には、**Go ランタイム**が OS スレッドを管理し、  
- 多数のゴルーチンを少数の OS スレッドに割り当てます。
- ゴルーチンは OS スレッドそのものではない  
- Go ランタイムの **M:N スケジューラ**により効率的に割り当てられる  
- 多数のゴルーチンを少数の OS スレッドで並行処理できる  




---

## 💡 その他気づいたこと
- 特になし


---

## 🛠️ コンテンツの改善点
- 制御構文以降の章で概念の説明が少ないため、受講者のレベルに合わせて、他の参考文献を間に挟んだ方がスムーズに学習が進められる可能性がある
- 練習問題がかなりハードなのと、クリアしてもそれが最適なコードなのかがわからないので、ヒントや模範解答、その補足説明などがあると、より理解度が深まるように感じた。



